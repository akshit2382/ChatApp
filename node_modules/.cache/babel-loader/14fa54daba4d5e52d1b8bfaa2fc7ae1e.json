{"ast":null,"code":"import { systemToComponent as e } from \"@virtuoso.dev/react-urx\";\nimport { system as t, stream as n, statefulStream as o, connect as r, pipe as i, map as l, getValue as a, streamFromEmitter as u, filter as s, distinctUntilChanged as c, subscribe as d, tup as f, merge as m, duc as h, skip as p, mapTo as g, debounceTime as v, statefulStreamFromEmitter as I, combineLatest as C, scan as S, publish as x, throttleTime as T, withLatestFrom as w, handleNext as y, noop as b, prop as H, tap as R, compose as z } from \"@virtuoso.dev/urx\";\nimport { useRef as k, useCallback as B, useEffect as E, useLayoutEffect as L, memo as P, createElement as O } from \"react\";\n\nfunction M() {\n  return (M = Object.assign || function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n\n      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);\n    }\n\n    return e;\n  }).apply(this, arguments);\n}\n\nfunction A(e, t) {\n  if (null == e) return {};\n  var n,\n      o,\n      r = {},\n      i = Object.keys(e);\n\n  for (o = 0; o < i.length; o++) t.indexOf(n = i[o]) >= 0 || (r[n] = e[n]);\n\n  return r;\n}\n\nfunction V(e, t) {\n  (null == t || t > e.length) && (t = e.length);\n\n  for (var n = 0, o = new Array(t); n < t; n++) o[n] = e[n];\n\n  return o;\n}\n\nfunction W(e, t) {\n  var n;\n\n  if (\"undefined\" == typeof Symbol || null == e[Symbol.iterator]) {\n    if (Array.isArray(e) || (n = function (e, t) {\n      if (e) {\n        if (\"string\" == typeof e) return V(e, t);\n        var n = Object.prototype.toString.call(e).slice(8, -1);\n        return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(e) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? V(e, t) : void 0;\n      }\n    }(e)) || t && e && \"number\" == typeof e.length) {\n      n && (e = n);\n      var o = 0;\n      return function () {\n        return o >= e.length ? {\n          done: !0\n        } : {\n          done: !1,\n          value: e[o++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  return (n = e[Symbol.iterator]()).next.bind(n);\n}\n\nfunction D(e, t) {\n  return !(!e || e[0] !== t[0] || e[1] !== t[1]);\n}\n\nfunction F(e, t) {\n  return !(!e || e.startIndex !== t.startIndex || e.endIndex !== t.endIndex);\n}\n\nvar G,\n    N,\n    U = t(function () {\n  var e = n(),\n      t = n(),\n      a = o(0),\n      u = n(),\n      s = o(0),\n      c = n(),\n      d = n(),\n      f = o(0),\n      m = o(0),\n      h = n(),\n      p = n(),\n      g = o(!1);\n  return r(i(e, l(function (e) {\n    return e[0];\n  })), t), r(i(e, l(function (e) {\n    return e[1];\n  })), d), r(t, s), {\n    scrollContainerState: e,\n    scrollTop: t,\n    viewportHeight: c,\n    headerHeight: f,\n    footerHeight: m,\n    scrollHeight: d,\n    smoothScrollTargetReached: u,\n    scrollTo: h,\n    scrollBy: p,\n    statefulScrollTop: s,\n    deviation: a,\n    scrollingInProgress: g\n  };\n}, [], {\n  singleton: !0\n});\n!function (e) {\n  e[e.DEBUG = 0] = \"DEBUG\", e[e.INFO = 1] = \"INFO\", e[e.WARN = 2] = \"WARN\", e[e.ERROR = 3] = \"ERROR\";\n}(N || (N = {}));\n\nvar _ = ((G = {})[N.DEBUG] = \"debug\", G[N.INFO] = \"log\", G[N.WARN] = \"warn\", G[N.ERROR] = \"error\", G),\n    j = t(function () {\n  var e = o(N.ERROR);\n  return {\n    log: o(function (t, n, o) {\n      var r;\n      void 0 === o && (o = N.INFO), o >= (null != (r = (\"undefined\" == typeof globalThis ? window : globalThis).VIRTUOSO_LOG_LEVEL) ? r : a(e)) && console[_[o]](\"%creact-virtuoso: %c%s %o\", \"color: #0253b3; font-weight: bold\", \"color: initial\", t, n);\n    }),\n    logLevel: e\n  };\n}, [], {\n  singleton: !0\n}),\n    K = t(function (e) {\n  var t = e[0].log,\n      n = o(!1),\n      r = u(i(n, s(function (e) {\n    return e;\n  }), c()));\n  return d(n, function (e) {\n    e && a(t)(\"props updated\", {}, N.DEBUG);\n  }), {\n    propsReady: n,\n    didMount: r\n  };\n}, f(j), {\n  singleton: !0\n}),\n    Y = \"up\",\n    Z = {\n  atBottom: !1,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n},\n    q = t(function (e) {\n  var t = e[0],\n      f = t.scrollContainerState,\n      y = t.scrollTop,\n      b = t.viewportHeight,\n      H = t.headerHeight,\n      R = t.footerHeight,\n      z = t.scrollBy,\n      k = o(!1),\n      B = o(!0),\n      E = n(),\n      L = n(),\n      P = o(4),\n      O = u(i(m(i(h(y), p(1), g(!0)), i(h(y), p(1), g(!1), v(100))), c())),\n      M = I(i(m(i(z, g(!0)), i(z, g(!1), v(200))), c()), !1);\n  r(i(h(y), l(function (e) {\n    return 0 === e;\n  }), c()), B), r(B, L);\n  var A = u(i(C(f, h(b), h(H), h(R), h(P)), S(function (e, t) {\n    var n,\n        o,\n        r = t[0],\n        i = r[0],\n        l = r[1],\n        a = t[1],\n        u = {\n      viewportHeight: a,\n      scrollTop: i,\n      scrollHeight: l\n    };\n    return i + a - l > -t[4] ? (i > e.state.scrollTop ? (n = \"SCROLLED_DOWN\", o = e.state.scrollTop - i) : (n = \"SIZE_DECREASED\", o = e.state.scrollTop - i || e.scrollTopDelta), {\n      atBottom: !0,\n      state: u,\n      atBottomBecause: n,\n      scrollTopDelta: o\n    }) : {\n      atBottom: !1,\n      notAtBottomBecause: u.scrollHeight > e.state.scrollHeight ? \"SIZE_INCREASED\" : a < e.state.viewportHeight ? \"VIEWPORT_HEIGHT_DECREASING\" : i < e.state.scrollTop ? \"SCROLLING_UPWARDS\" : \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\",\n      state: u\n    };\n  }, Z), c(function (e, t) {\n    return e && e.atBottom === t.atBottom;\n  }))),\n      V = I(i(f, S(function (e, t) {\n    var n = t[0],\n        o = t[1];\n    return e.scrollHeight !== o ? e.scrollTop !== n ? {\n      scrollHeight: o,\n      scrollTop: n,\n      jump: e.scrollTop - n,\n      changed: !0\n    } : {\n      scrollHeight: o,\n      scrollTop: n,\n      jump: 0,\n      changed: !0\n    } : {\n      scrollTop: n,\n      scrollHeight: o,\n      jump: 0,\n      changed: !1\n    };\n  }, {\n    scrollHeight: 0,\n    jump: 0,\n    scrollTop: 0,\n    changed: !1\n  }), s(function (e) {\n    return e.changed;\n  }), l(function (e) {\n    return e.jump;\n  })), 0);\n  r(i(A, l(function (e) {\n    return e.atBottom;\n  })), k), d(k, function (e) {\n    setTimeout(function () {\n      return x(E, e);\n    });\n  });\n  var W = o(\"down\");\n  d(k, function (e) {\n    setTimeout(function () {\n      x(E, e);\n    });\n  }), r(i(f, l(function (e) {\n    return e[0];\n  }), c(), S(function (e, t) {\n    return a(M) ? {\n      direction: e.direction,\n      prevScrollTop: t\n    } : {\n      direction: t < e.prevScrollTop ? Y : \"down\",\n      prevScrollTop: t\n    };\n  }, {\n    direction: \"down\",\n    prevScrollTop: 0\n  }), l(function (e) {\n    return e.direction;\n  })), W), r(i(f, T(50), g(\"none\")), W), r(k, E);\n  var D = o(0);\n  return r(i(O, s(function (e) {\n    return !e;\n  }), g(0)), D), r(i(y, T(100), w(O), s(function (e) {\n    return !!e[1];\n  }), S(function (e, t) {\n    return [e[1], t[0]];\n  }, [0, 0]), l(function (e) {\n    return e[1] - e[0];\n  })), D), {\n    isScrolling: O,\n    isAtTop: B,\n    isAtBottom: k,\n    atBottomState: A,\n    atTopStateChange: L,\n    atBottomStateChange: E,\n    scrollDirection: W,\n    atBottomThreshold: P,\n    scrollVelocity: D,\n    lastJumpDueToItemResize: V\n  };\n}, f(U)),\n    J = t(function (e) {\n  var t = e[0].scrollVelocity,\n      a = o(!1),\n      u = n(),\n      f = o(!1);\n  return r(i(t, w(f, a, u), s(function (e) {\n    return !!e[1];\n  }), l(function (e) {\n    var t = e[0],\n        n = e[1],\n        o = e[2],\n        r = e[3],\n        i = n.enter;\n\n    if (o) {\n      if ((0, n.exit)(t, r)) return !1;\n    } else if (i(t, r)) return !0;\n\n    return o;\n  }), c()), a), d(i(C(a, t, u), w(f)), function (e) {\n    var t = e[0],\n        n = e[1];\n    return t[0] && n && n.change && n.change(t[1], t[2]);\n  }), {\n    isSeeking: a,\n    scrollSeekConfiguration: f,\n    scrollVelocity: t,\n    scrollSeekRangeChanged: u\n  };\n}, f(q), {\n  singleton: !0\n}),\n    $ = {\n  lvl: 0\n};\n\nfunction Q(e, t, n, o, r) {\n  return void 0 === o && (o = $), void 0 === r && (r = $), {\n    k: e,\n    v: t,\n    lvl: n,\n    l: o,\n    r: r\n  };\n}\n\nfunction X(e) {\n  return e === $;\n}\n\nfunction ee() {\n  return $;\n}\n\nfunction te(e, t) {\n  if (X(e)) return $;\n  var n = e.k,\n      o = e.l,\n      r = e.r;\n\n  if (t === n) {\n    if (X(o)) return r;\n    if (X(r)) return o;\n    var i = le(o);\n    return ce(ue(e, {\n      k: i[0],\n      v: i[1],\n      l: ae(o)\n    }));\n  }\n\n  return ce(ue(e, t < n ? {\n    l: te(o, t)\n  } : {\n    r: te(r, t)\n  }));\n}\n\nfunction ne(e, t, n) {\n  if (void 0 === n && (n = \"k\"), X(e)) return [-Infinity, void 0];\n  if (e[n] === t) return [e.k, e.v];\n\n  if (e[n] < t) {\n    var o = ne(e.r, t, n);\n    return -Infinity === o[0] ? [e.k, e.v] : o;\n  }\n\n  return ne(e.l, t, n);\n}\n\nfunction oe(e, t, n) {\n  return X(e) ? Q(t, n, 1) : t === e.k ? ue(e, {\n    k: t,\n    v: n\n  }) : function (e) {\n    return me(he(e));\n  }(ue(e, t < e.k ? {\n    l: oe(e.l, t, n)\n  } : {\n    r: oe(e.r, t, n)\n  }));\n}\n\nfunction re(e, t, n) {\n  if (X(e)) return [];\n  var o = e.k,\n      r = e.v,\n      i = e.r,\n      l = [];\n  return o > t && (l = l.concat(re(e.l, t, n))), o >= t && o <= n && l.push({\n    k: o,\n    v: r\n  }), o <= n && (l = l.concat(re(i, t, n))), l;\n}\n\nfunction ie(e) {\n  return X(e) ? [] : [].concat(ie(e.l), [{\n    k: e.k,\n    v: e.v\n  }], ie(e.r));\n}\n\nfunction le(e) {\n  return X(e.r) ? [e.k, e.v] : le(e.r);\n}\n\nfunction ae(e) {\n  return X(e.r) ? e.l : ce(ue(e, {\n    r: ae(e.r)\n  }));\n}\n\nfunction ue(e, t) {\n  return Q(void 0 !== t.k ? t.k : e.k, void 0 !== t.v ? t.v : e.v, void 0 !== t.lvl ? t.lvl : e.lvl, void 0 !== t.l ? t.l : e.l, void 0 !== t.r ? t.r : e.r);\n}\n\nfunction se(e) {\n  return X(e) || e.lvl > e.r.lvl;\n}\n\nfunction ce(e) {\n  var t = e.l,\n      n = e.r,\n      o = e.lvl;\n  if (n.lvl >= o - 1 && t.lvl >= o - 1) return e;\n\n  if (o > n.lvl + 1) {\n    if (se(t)) return he(ue(e, {\n      lvl: o - 1\n    }));\n    if (X(t) || X(t.r)) throw new Error(\"Unexpected empty nodes\");\n    return ue(t.r, {\n      l: ue(t, {\n        r: t.r.l\n      }),\n      r: ue(e, {\n        l: t.r.r,\n        lvl: o - 1\n      }),\n      lvl: o\n    });\n  }\n\n  if (se(e)) return me(ue(e, {\n    lvl: o - 1\n  }));\n  if (X(n) || X(n.l)) throw new Error(\"Unexpected empty nodes\");\n  var r = n.l,\n      i = se(r) ? n.lvl - 1 : n.lvl;\n  return ue(r, {\n    l: ue(e, {\n      r: r.l,\n      lvl: o - 1\n    }),\n    r: me(ue(n, {\n      l: r.r,\n      lvl: i\n    })),\n    lvl: r.lvl + 1\n  });\n}\n\nfunction de(e, t, n) {\n  return X(e) ? [] : fe(re(e, ne(e, t)[0], n), function (e) {\n    return {\n      index: e.k,\n      value: e.v\n    };\n  });\n}\n\nfunction fe(e, t) {\n  var n = e.length;\n  if (0 === n) return [];\n\n  for (var o = t(e[0]), r = o.index, i = o.value, l = [], a = 1; a < n; a++) {\n    var u = t(e[a]),\n        s = u.index,\n        c = u.value;\n    l.push({\n      start: r,\n      end: s - 1,\n      value: i\n    }), r = s, i = c;\n  }\n\n  return l.push({\n    start: r,\n    end: Infinity,\n    value: i\n  }), l;\n}\n\nfunction me(e) {\n  var t = e.r,\n      n = e.lvl;\n  return X(t) || X(t.r) || t.lvl !== n || t.r.lvl !== n ? e : ue(t, {\n    l: ue(e, {\n      r: t.l\n    }),\n    lvl: n + 1\n  });\n}\n\nfunction he(e) {\n  var t = e.l;\n  return X(t) || t.lvl !== e.lvl ? e : ue(t, {\n    r: ue(e, {\n      l: t.r\n    })\n  });\n}\n\nfunction pe(e, t, n, o) {\n  void 0 === o && (o = 0);\n\n  for (var r = e.length - 1; o <= r;) {\n    var i = Math.floor((o + r) / 2),\n        l = n(e[i], t);\n    if (0 === l) return i;\n\n    if (-1 === l) {\n      if (r - o < 2) return i - 1;\n      r = i - 1;\n    } else {\n      if (r === o) return i;\n      o = i + 1;\n    }\n  }\n\n  throw new Error(\"Failed binary finding record in array - \" + e.join(\",\") + \", searched for \" + t);\n}\n\nfunction ge(e, t, n) {\n  return e[pe(e, t, n)];\n}\n\nfunction ve(e, t) {\n  return Math.round(e.getBoundingClientRect()[t]);\n}\n\nfunction Ie(e) {\n  var t = e.size,\n      n = e.startIndex,\n      o = e.endIndex;\n  return function (e) {\n    return e.start === n && (e.end === o || Infinity === e.end) && e.value === t;\n  };\n}\n\nfunction Ce(e, t) {\n  var n = e.index;\n  return t === n ? 0 : t < n ? -1 : 1;\n}\n\nfunction Se(e, t) {\n  var n = e.offset;\n  return t === n ? 0 : t < n ? -1 : 1;\n}\n\nfunction xe(e) {\n  return {\n    index: e.index,\n    value: e\n  };\n}\n\nfunction Te(e, t) {\n  var n = t[0],\n      o = t[1];\n  n.length > 0 && (0, t[2])(\"received item sizes\", n, N.DEBUG);\n  var r = e.sizeTree,\n      i = e.offsetTree,\n      l = r,\n      a = 0;\n\n  if (o.length > 0 && X(r) && 2 === n.length) {\n    var u = n[0].size,\n        s = n[1].size;\n    l = o.reduce(function (e, t) {\n      return oe(oe(e, t, u), t + 1, s);\n    }, l);\n  } else {\n    var c = function (e, t) {\n      for (var n, o = X(e) ? 0 : Infinity, r = W(t); !(n = r()).done;) {\n        var i = n.value,\n            l = i.size,\n            a = i.startIndex,\n            u = i.endIndex;\n        if (o = Math.min(o, a), X(e)) e = oe(e, 0, l);else {\n          var s = de(e, a - 1, u + 1);\n\n          if (!s.some(Ie(i))) {\n            for (var c, d = !1, f = !1, m = W(s); !(c = m()).done;) {\n              var h = c.value,\n                  p = h.start,\n                  g = h.end,\n                  v = h.value;\n              d ? (u >= p || l === v) && (e = te(e, p)) : (f = v !== l, d = !0), g > u && u >= p && v !== l && (e = oe(e, u + 1, v));\n            }\n\n            f && (e = oe(e, a, l));\n          }\n        }\n      }\n\n      return [e, o];\n    }(l, n);\n\n    l = c[0], a = c[1];\n  }\n\n  if (l === r) return e;\n  var d = 0,\n      f = 0,\n      m = 0,\n      h = 0;\n\n  if (0 !== a) {\n    h = pe(i, a - 1, Ce), m = i[h].offset;\n    var p = ne(l, a - 1);\n    d = p[0], f = p[1], i.length && i[h].size === ne(l, a)[1] && (h -= 1), i = i.slice(0, h + 1);\n  } else i = [];\n\n  for (var g, v = W(de(l, a, Infinity)); !(g = v()).done;) {\n    var I = g.value,\n        C = I.start,\n        S = I.value,\n        x = (C - d) * f + m;\n    i.push({\n      offset: x,\n      size: S,\n      index: C\n    }), d = C, m = x, f = S;\n  }\n\n  return {\n    sizeTree: l,\n    offsetTree: i,\n    groupOffsetTree: o.reduce(function (e, t) {\n      return oe(e, t, we(t, i));\n    }, ee()),\n    lastIndex: d,\n    lastOffset: m,\n    lastSize: f,\n    groupIndices: o\n  };\n}\n\nfunction we(e, t) {\n  if (0 === t.length) return 0;\n  var n = ge(t, e, Ce);\n  return n.size * (e - n.index) + n.offset;\n}\n\nfunction ye(e, t) {\n  if (!be(t)) return e;\n\n  for (var n = 0; t.groupIndices[n] <= e + n;) n++;\n\n  return e + n;\n}\n\nfunction be(e) {\n  return !X(e.groupOffsetTree);\n}\n\nvar He = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n},\n    Re = t(function (e) {\n  var t = e[0].log,\n      f = n(),\n      m = n(),\n      h = I(m, 0),\n      p = n(),\n      g = o(0),\n      v = o([]),\n      C = o(void 0),\n      x = o(void 0),\n      T = o(function (e, t) {\n    return ve(e, He[t]);\n  }),\n      y = o(void 0),\n      b = {\n    offsetTree: [],\n    sizeTree: ee(),\n    groupOffsetTree: ee(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  },\n      H = I(i(f, w(v, t), S(Te, b), c()), b);\n  r(i(v, s(function (e) {\n    return e.length > 0;\n  }), w(H), l(function (e) {\n    var t = e[0],\n        n = e[1],\n        o = t.reduce(function (e, t, o) {\n      return oe(e, t, we(t, n.offsetTree) || o);\n    }, ee());\n    return M({}, n, {\n      groupIndices: t,\n      groupOffsetTree: o\n    });\n  })), H), r(i(m, w(H), s(function (e) {\n    return e[0] < e[1].lastIndex;\n  }), l(function (e) {\n    var t = e[1];\n    return [{\n      startIndex: e[0],\n      endIndex: t.lastIndex,\n      size: t.lastSize\n    }];\n  })), f), r(C, x);\n  var R = I(i(C, l(function (e) {\n    return void 0 === e;\n  })), !0);\n  r(i(x, s(function (e) {\n    return void 0 !== e && X(a(H).sizeTree);\n  }), l(function (e) {\n    return [{\n      startIndex: 0,\n      endIndex: 0,\n      size: e\n    }];\n  })), f);\n  var z = u(i(f, w(H), S(function (e, t) {\n    var n = t[1];\n    return {\n      changed: n !== e.sizes,\n      sizes: n\n    };\n  }, {\n    changed: !1,\n    sizes: b\n  }), l(function (e) {\n    return e.changed;\n  })));\n  r(i(g, S(function (e, t) {\n    return {\n      diff: e.prev - t,\n      prev: t\n    };\n  }, {\n    diff: 0,\n    prev: 0\n  }), l(function (e) {\n    return e.diff;\n  }), s(function (e) {\n    return e > 0;\n  })), p), d(i(g, w(t)), function (e) {\n    e[0] < 0 && (0, e[1])(\"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\", {\n      firstItemIndex: g\n    }, N.ERROR);\n  });\n  var k = u(p);\n  return r(i(p, w(H), l(function (e) {\n    var t = e[0],\n        n = e[1];\n    if (n.groupIndices.length > 0) throw new Error(\"Virtuoso: prepending items does not work with groups\");\n    return ie(n.sizeTree).reduce(function (e, n) {\n      var o = n.k,\n          r = n.v;\n      return {\n        ranges: [].concat(e.ranges, [{\n          startIndex: e.prevIndex,\n          endIndex: o + t - 1,\n          size: e.prevSize\n        }]),\n        prevIndex: o + t,\n        prevSize: r\n      };\n    }, {\n      ranges: [],\n      prevIndex: 0,\n      prevSize: n.lastSize\n    }).ranges;\n  })), f), {\n    data: y,\n    totalCount: m,\n    sizeRanges: f,\n    groupIndices: v,\n    defaultItemSize: x,\n    fixedItemSize: C,\n    unshiftWith: p,\n    beforeUnshiftWith: k,\n    firstItemIndex: g,\n    sizes: H,\n    listRefresh: z,\n    statefulTotalCount: h,\n    trackItemSizes: R,\n    itemSize: T\n  };\n}, f(j), {\n  singleton: !0\n}),\n    ze = \"undefined\" != typeof document && \"scrollBehavior\" in document.documentElement.style;\n\nfunction ke(e) {\n  var t = \"number\" == typeof e ? {\n    index: e\n  } : e;\n  return t.align || (t.align = \"start\"), t.behavior && ze || (t.behavior = \"auto\"), t.offset || (t.offset = 0), t;\n}\n\nvar Be = t(function (e) {\n  var t = e[0],\n      a = t.sizes,\n      u = t.totalCount,\n      s = t.listRefresh,\n      c = e[1],\n      f = c.scrollingInProgress,\n      m = c.viewportHeight,\n      h = c.scrollTo,\n      p = c.smoothScrollTargetReached,\n      g = c.headerHeight,\n      v = c.footerHeight,\n      I = e[2].log,\n      C = n(),\n      S = o(0),\n      T = null,\n      b = null,\n      H = null;\n\n  function R() {\n    T && (T(), T = null), H && (H(), H = null), b && (clearTimeout(b), b = null), x(f, !1);\n  }\n\n  return r(i(C, w(a, m, u, S, g, v, I), l(function (e) {\n    var t = e[0],\n        n = e[1],\n        o = e[2],\n        r = e[3],\n        l = e[4],\n        a = e[5],\n        u = e[6],\n        c = e[7],\n        m = ke(t),\n        h = m.align,\n        g = m.behavior,\n        v = m.offset,\n        I = r - 1,\n        S = m.index;\n    \"LAST\" === S && (S = I), S = ye(S, n);\n    var w = we(S = Math.max(0, S, Math.min(I, S)), n.offsetTree) + a;\n    \"end\" === h ? (w = w - o + ne(n.sizeTree, S)[1], S === I && (w += u)) : \"center\" === h ? w = w - o / 2 + ne(n.sizeTree, S)[1] / 2 : w -= l, v && (w += v);\n\n    var z = function (e) {\n      R(), e ? (c(\"retrying to scroll to\", {\n        location: t\n      }, N.DEBUG), x(C, t)) : c(\"list did not change, scroll successful\", {}, N.DEBUG);\n    };\n\n    if (R(), \"smooth\" === g) {\n      var k = !1;\n      H = d(s, function (e) {\n        k = k || e;\n      }), T = y(p, function () {\n        z(k);\n      });\n    } else T = y(i(s, function (e) {\n      var t = setTimeout(function () {\n        e(!1);\n      }, 50);\n      return function (n) {\n        n && (e(!0), clearTimeout(t));\n      };\n    }), z);\n\n    return b = setTimeout(function () {\n      R();\n    }, 1200), x(f, !0), c(\"scrolling from index to\", {\n      index: S,\n      top: w,\n      behavior: g\n    }, N.DEBUG), {\n      top: w,\n      behavior: g\n    };\n  })), h), {\n    scrollToIndex: C,\n    topListHeight: S\n  };\n}, f(Re, U, j), {\n  singleton: !0\n});\n\nfunction Ee(e, t, n) {\n  return \"number\" == typeof e ? n === Y && \"top\" === t || \"down\" === n && \"bottom\" === t ? e : 0 : n === Y ? \"top\" === t ? e.main : e.reverse : \"bottom\" === t ? e.main : e.reverse;\n}\n\nfunction Le(e, t) {\n  return \"number\" == typeof e ? e : e[t] || 0;\n}\n\nvar Pe = t(function (e) {\n  var t = e[0],\n      r = t.scrollTop,\n      a = t.viewportHeight,\n      u = t.deviation,\n      d = t.headerHeight,\n      f = n(),\n      m = o(0),\n      p = o(0),\n      g = o(0),\n      v = o(0);\n  return {\n    listBoundary: f,\n    overscan: v,\n    topListHeight: m,\n    fixedHeaderHeight: p,\n    increaseViewportBy: g,\n    visibleRange: I(i(C(h(r), h(a), h(d), h(f, D), h(v), h(m), h(p), h(u), h(g)), l(function (e) {\n      var t = e[0],\n          n = e[1],\n          o = e[2],\n          r = e[3],\n          i = r[0],\n          l = r[1],\n          a = e[4],\n          u = e[6],\n          s = e[7],\n          c = e[8],\n          d = t - s,\n          f = e[5] + u,\n          m = Math.max(o - d, 0),\n          h = \"none\",\n          p = Le(c, \"top\"),\n          g = Le(c, \"bottom\");\n      return i -= s, l += o, (i += o) > t + f - p && (h = Y), (l -= s) < t - m + n + g && (h = \"down\"), \"none\" !== h ? [Math.max(d - o - Ee(a, \"top\", h) - p, 0), d - m - u + n + Ee(a, \"bottom\", h) + g] : null;\n    }), s(function (e) {\n      return null != e;\n    }), c(D)), [0, 0])\n  };\n}, f(U), {\n  singleton: !0\n}),\n    Oe = t(function (e) {\n  var t = e[0],\n      a = t.scrollTo,\n      u = t.scrollContainerState,\n      s = n(),\n      c = n(),\n      d = n(),\n      f = o(!1),\n      m = o(void 0);\n  return r(i(C(s, c), l(function (e) {\n    var t = e[0],\n        n = t[1];\n    return [Math.max(0, t[0] - e[1].offsetTop), n];\n  })), u), r(i(a, w(c), l(function (e) {\n    var t = e[0];\n    return M({}, t, {\n      top: t.top + e[1].offsetTop\n    });\n  })), d), {\n    useWindowScroll: f,\n    customScrollParent: m,\n    windowScrollContainerState: s,\n    windowViewportRect: c,\n    windowScrollTo: d\n  };\n}, f(U)),\n    Me = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n},\n    Ae = {\n  items: [{\n    index: 0\n  }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n},\n    Ve = Math.ceil,\n    We = Math.floor,\n    De = Math.min,\n    Fe = Math.max;\n\nfunction Ge(e, t) {\n  return Array.from({\n    length: t - e + 1\n  }).map(function (t, n) {\n    return {\n      index: n + e\n    };\n  });\n}\n\nvar Ne = t(function (e) {\n  var t = e[0],\n      a = t.overscan,\n      d = t.visibleRange,\n      f = t.listBoundary,\n      m = e[1],\n      p = m.scrollTop,\n      v = m.viewportHeight,\n      S = m.scrollBy,\n      x = m.scrollTo,\n      T = m.smoothScrollTargetReached,\n      y = m.scrollContainerState,\n      b = e[2],\n      H = e[3],\n      R = e[4],\n      z = R.propsReady,\n      k = R.didMount,\n      B = e[5],\n      E = B.windowViewportRect,\n      L = B.windowScrollTo,\n      P = B.useWindowScroll,\n      O = B.customScrollParent,\n      A = B.windowScrollContainerState,\n      V = o(0),\n      W = o(0),\n      G = o(Me),\n      N = o({\n    height: 0,\n    width: 0\n  }),\n      U = o({\n    height: 0,\n    width: 0\n  }),\n      _ = n(),\n      j = n(),\n      K = o(0);\n\n  r(i(k, w(W), s(function (e) {\n    return 0 !== e[1];\n  }), l(function (e) {\n    return {\n      items: Ge(0, e[1] - 1),\n      top: 0,\n      bottom: 0,\n      offsetBottom: 0,\n      offsetTop: 0,\n      itemHeight: 0,\n      itemWidth: 0\n    };\n  })), G), r(i(C(h(V), d, h(U, function (e, t) {\n    return e && e.width === t.width && e.height === t.height;\n  })), w(N), l(function (e) {\n    var t = e[0],\n        n = t[0],\n        o = t[1],\n        r = o[0],\n        i = o[1],\n        l = t[2],\n        a = e[1],\n        u = l.height,\n        s = l.width,\n        c = a.width;\n    if (0 === n || 0 === c) return Me;\n    if (0 === s) return Ae;\n    var d = Math.floor(c / s),\n        f = d * We(r / u),\n        m = d * Ve(i / u) - 1;\n    m = De(n - 1, m);\n    var h = Ge(f = De(m, Fe(0, f)), m),\n        p = Ue(a, l, h),\n        g = p.top,\n        v = p.bottom;\n    return {\n      items: h,\n      offsetTop: g,\n      offsetBottom: Ve(n / d) * u - v,\n      top: g,\n      bottom: v,\n      itemHeight: u,\n      itemWidth: s\n    };\n  })), G), r(i(N, l(function (e) {\n    return e.height;\n  })), v), r(i(C(N, U, G), l(function (e) {\n    var t = Ue(e[0], e[1], e[2].items);\n    return [t.top, t.bottom];\n  }), c(D)), f);\n  var Y = u(i(h(G), s(function (e) {\n    return e.items.length > 0;\n  }), w(V), s(function (e) {\n    var t = e[0].items;\n    return t[t.length - 1].index === e[1] - 1;\n  }), l(function (e) {\n    return e[1] - 1;\n  }), c())),\n      Z = u(i(h(G), s(function (e) {\n    var t = e.items;\n    return t.length > 0 && 0 === t[0].index;\n  }), g(0), c())),\n      q = u(i(h(G), s(function (e) {\n    return e.items.length > 0;\n  }), l(function (e) {\n    var t = e.items;\n    return {\n      startIndex: t[0].index,\n      endIndex: t[t.length - 1].index\n    };\n  }), c(F)));\n  r(q, H.scrollSeekRangeChanged), r(i(_, w(N, U, V), l(function (e) {\n    var t = e[1],\n        n = e[2],\n        o = e[3],\n        r = ke(e[0]),\n        i = r.align,\n        l = r.behavior,\n        a = r.offset,\n        u = r.index;\n    \"LAST\" === u && (u = o - 1);\n\n    var s = _e(t, n, u = Math.max(0, u, Math.min(o - 1, u)));\n\n    return \"end\" === i ? s = Math.round(s - t.height + n.height) : \"center\" === i && (s = Math.round(s - t.height / 2 + n.height / 2)), a && (s += a), {\n      top: s,\n      behavior: l\n    };\n  })), x);\n  var J = I(i(G, l(function (e) {\n    return e.offsetBottom + e.bottom;\n  })), 0);\n  return r(i(E, l(function (e) {\n    return {\n      width: e.visibleWidth,\n      height: e.visibleHeight\n    };\n  })), N), M({\n    totalCount: V,\n    viewportDimensions: N,\n    itemDimensions: U,\n    scrollTop: p,\n    scrollHeight: j,\n    overscan: a,\n    scrollBy: S,\n    scrollTo: x,\n    scrollToIndex: _,\n    smoothScrollTargetReached: T,\n    windowViewportRect: E,\n    windowScrollTo: L,\n    useWindowScroll: P,\n    customScrollParent: O,\n    windowScrollContainerState: A,\n    deviation: K,\n    scrollContainerState: y,\n    initialItemCount: W\n  }, H, {\n    gridState: G,\n    totalListHeight: J\n  }, b, {\n    startReached: Z,\n    endReached: Y,\n    rangeChanged: q,\n    propsReady: z\n  });\n}, f(Pe, U, q, J, K, Oe));\n\nfunction Ue(e, t, n) {\n  var o = t.height;\n  return void 0 === o || 0 === n.length ? {\n    top: 0,\n    bottom: 0\n  } : {\n    top: _e(e, t, n[0].index),\n    bottom: _e(e, t, n[n.length - 1].index) + o\n  };\n}\n\nfunction _e(e, t, n) {\n  var o = Math.floor(e.width / t.width);\n  return We(n / o) * t.height;\n}\n\nfunction je(e, t) {\n  void 0 === t && (t = !0);\n\n  var n = k(null),\n      o = function (e) {};\n\n  if (\"undefined\" != typeof ResizeObserver) {\n    var r = new ResizeObserver(function (t) {\n      var n = t[0].target;\n      null !== n.offsetParent && e(n);\n    });\n\n    o = function (e) {\n      e && t ? (r.observe(e), n.current = e) : (n.current && r.unobserve(n.current), n.current = null);\n    };\n  }\n\n  return {\n    ref: n,\n    callbackRef: o\n  };\n}\n\nfunction Ke(e, t) {\n  return void 0 === t && (t = !0), je(e, t).callbackRef;\n}\n\nfunction Ye(e, t) {\n  var n = k(null),\n      o = B(function (o) {\n    if (null !== o) {\n      var r,\n          i,\n          l = o.getBoundingClientRect(),\n          a = l.width;\n\n      if (t) {\n        var u = t.getBoundingClientRect(),\n            s = l.top - u.top;\n        r = u.height - Math.max(0, s), i = s + t.scrollTop;\n      } else r = window.innerHeight - Math.max(0, l.top), i = l.top + window.pageYOffset;\n\n      n.current = {\n        offsetTop: i,\n        visibleHeight: r,\n        visibleWidth: a\n      }, e(n.current);\n    }\n  }, [e, t]),\n      r = je(o),\n      i = r.callbackRef,\n      l = r.ref,\n      a = B(function () {\n    o(l.current);\n  }, [o, l]);\n  return E(function () {\n    if (t) {\n      t.addEventListener(\"scroll\", a);\n      var e = new ResizeObserver(a);\n      return e.observe(t), function () {\n        t.removeEventListener(\"scroll\", a), e.unobserve(t);\n      };\n    }\n\n    return window.addEventListener(\"scroll\", a), window.addEventListener(\"resize\", a), function () {\n      window.removeEventListener(\"scroll\", a), window.removeEventListener(\"resize\", a);\n    };\n  }, [a, t]), i;\n}\n\nvar Ze = \"undefined\" != typeof document ? L : E;\n\nfunction qe(e, t, n, o, r, i) {\n  return Ke(function (n) {\n    for (var l = function (e, t, n, o) {\n      var r = e.length;\n      if (0 === r) return null;\n\n      for (var i = [], l = 0; l < r; l++) {\n        var a = e.item(l);\n\n        if (a && void 0 !== a.dataset.index) {\n          var u = parseInt(a.dataset.index),\n              s = parseFloat(a.dataset.knownSize),\n              c = t(a, \"offsetHeight\");\n\n          if (0 === c && o(\"Zero-sized element, this should not happen\", {\n            child: a\n          }, N.ERROR), c !== s) {\n            var d = i[i.length - 1];\n            0 === i.length || d.size !== c || d.endIndex !== u - 1 ? i.push({\n              startIndex: u,\n              endIndex: u,\n              size: c\n            }) : i[i.length - 1].endIndex++;\n          }\n        }\n      }\n\n      return i;\n    }(n.children, t, 0, r), a = n.parentElement; !a.dataset.virtuosoScroller;) a = a.parentElement;\n\n    var u = i ? i.scrollTop : \"window\" === a.firstElementChild.dataset.viewportType ? window.pageYOffset || document.documentElement.scrollTop : a.scrollTop;\n    o(i ? [Math.max(u, 0), i.scrollHeight] : [Math.max(u, 0), a.scrollHeight]), null !== l && e(l);\n  }, n);\n}\n\nfunction Je(e, t, n, o, r) {\n  void 0 === o && (o = b);\n  var i = k(null),\n      l = k(null),\n      a = k(null),\n      u = B(function (n) {\n    var o = n.target,\n        r = o === window || o === document ? window.pageYOffset || document.documentElement.scrollTop : o.scrollTop,\n        i = o === window ? document.documentElement.scrollHeight : o.scrollHeight;\n    e([Math.max(r, 0), i]), null !== l.current && (r === l.current || r <= 0 || r === o.scrollHeight - ve(o, \"height\")) && (l.current = null, t(!0), a.current && (clearTimeout(a.current), a.current = null));\n  }, [e, t]);\n  return E(function () {\n    var e = r || i.current;\n    return o(r || i.current), u({\n      target: e\n    }), e.addEventListener(\"scroll\", u, {\n      passive: !0\n    }), function () {\n      o(null), e.removeEventListener(\"scroll\", u);\n    };\n  }, [i, u, n, o, r]), {\n    scrollerRef: i,\n    scrollByCallback: function (e) {\n      null === l.current && i.current.scrollBy(e);\n    },\n    scrollToCallback: function (n) {\n      var o = i.current;\n\n      if (o && (!(\"offsetHeight\" in o) || 0 !== o.offsetHeight)) {\n        var r,\n            u,\n            s,\n            c = \"smooth\" === n.behavior;\n        if (o === window ? (u = Math.max(ve(document.documentElement, \"height\"), document.documentElement.scrollHeight), r = window.innerHeight, s = document.documentElement.scrollTop) : (u = o.scrollHeight, r = ve(o, \"height\"), s = o.scrollTop), n.top = Math.ceil(Math.max(Math.min(u - r, n.top), 0)), Math.abs(r - u) < 1.01 || n.top === s) return e([s, u]), void (c && t(!0));\n        c ? (l.current = n.top, a.current && clearTimeout(a.current), a.current = setTimeout(function () {\n          a.current = null, l.current = null, t(!0);\n        }, 1e3)) : l.current = null, o.scrollTo(n);\n      }\n    }\n  };\n}\n\nvar $e = t(function (e) {\n  var t = e[0],\n      n = t.sizes,\n      l = t.listRefresh,\n      a = t.defaultItemSize,\n      u = e[1].scrollTop,\n      c = e[2].scrollToIndex,\n      f = e[3].didMount,\n      m = o(!0),\n      h = o(0);\n  return r(i(f, w(h), s(function (e) {\n    return 0 !== e[1];\n  }), g(!1)), m), d(i(C(l, f), w(m, n, a), s(function (e) {\n    var t = e[1],\n        n = e[3];\n    return e[0][1] && (!X(e[2].sizeTree) || void 0 !== n) && !t;\n  }), w(h)), function (e) {\n    var t = e[1];\n    setTimeout(function () {\n      y(u, function () {\n        x(m, !0);\n      }), x(c, t);\n    });\n  }), {\n    scrolledToInitialItem: m,\n    initialTopMostItemIndex: h\n  };\n}, f(Re, U, Be, K), {\n  singleton: !0\n});\n\nfunction Qe(e) {\n  return !!e && (\"smooth\" === e ? \"smooth\" : \"auto\");\n}\n\nvar Xe = t(function (e) {\n  var t = e[0],\n      n = t.totalCount,\n      r = t.listRefresh,\n      u = e[1],\n      c = u.isAtBottom,\n      f = u.atBottomState,\n      m = e[2].scrollToIndex,\n      g = e[3].scrolledToInitialItem,\n      v = e[4],\n      I = v.propsReady,\n      T = v.didMount,\n      b = e[5].log,\n      H = e[6].scrollingInProgress,\n      R = o(!1),\n      z = null;\n\n  function k(e) {\n    x(m, {\n      index: \"LAST\",\n      align: \"end\",\n      behavior: e\n    });\n  }\n\n  return d(i(C(i(h(n), p(1)), T), w(h(R), c, g, H), l(function (e) {\n    var t = e[0],\n        n = t[0],\n        o = t[1] && e[3],\n        r = \"auto\";\n    return o && (r = function (e, t) {\n      return \"function\" == typeof e ? Qe(e(t)) : t && Qe(e);\n    }(e[1], e[2] || e[4]), o = o && !!r), {\n      totalCount: n,\n      shouldFollow: o,\n      followOutputBehavior: r\n    };\n  }), s(function (e) {\n    return e.shouldFollow;\n  })), function (e) {\n    var t = e.totalCount,\n        n = e.followOutputBehavior;\n    z && (z(), z = null), z = y(r, function () {\n      a(b)(\"following output to \", {\n        totalCount: t\n      }, N.DEBUG), k(n), z = null;\n    });\n  }), d(i(C(h(R), n, I), s(function (e) {\n    return e[0] && e[2];\n  }), S(function (e, t) {\n    var n = t[1];\n    return {\n      refreshed: e.value === n,\n      value: n\n    };\n  }, {\n    refreshed: !1,\n    value: 0\n  }), s(function (e) {\n    return e.refreshed;\n  }), w(R, n)), function (e) {\n    var t = e[1],\n        n = y(f, function (e) {\n      !t || e.atBottom || \"SIZE_INCREASED\" !== e.notAtBottomBecause || z || (a(b)(\"scrolling to bottom due to increased size\", {}, N.DEBUG), k(\"auto\"));\n    });\n    setTimeout(n, 100);\n  }), d(C(h(R), f), function (e) {\n    var t = e[1];\n    e[0] && !t.atBottom && \"VIEWPORT_HEIGHT_DECREASING\" === t.notAtBottomBecause && k(\"auto\");\n  }), {\n    followOutput: R\n  };\n}, f(Re, q, Be, $e, K, j, U));\n\nfunction et(e) {\n  return e.reduce(function (e, t) {\n    return e.groupIndices.push(e.totalCount), e.totalCount += t + 1, e;\n  }, {\n    totalCount: 0,\n    groupIndices: []\n  });\n}\n\nvar tt = t(function (e) {\n  var t = e[0],\n      o = t.totalCount,\n      a = t.groupIndices,\n      d = t.sizes,\n      f = e[1],\n      m = f.scrollTop,\n      h = f.headerHeight,\n      p = n(),\n      g = n(),\n      v = u(i(p, l(et)));\n  return r(i(v, l(H(\"totalCount\"))), o), r(i(v, l(H(\"groupIndices\"))), a), r(i(C(m, d, h), s(function (e) {\n    return be(e[1]);\n  }), l(function (e) {\n    return ne(e[1].groupOffsetTree, Math.max(e[0] - e[2], 0), \"v\")[0];\n  }), c(), l(function (e) {\n    return [e];\n  })), g), {\n    groupCounts: p,\n    topItemsIndexes: g\n  };\n}, f(Re, U)),\n    nt = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0\n};\n\nfunction ot(e, t, n) {\n  if (0 === e.length) return [];\n  if (!be(t)) return e.map(function (e) {\n    return M({}, e, {\n      index: e.index + n,\n      originalIndex: e.index\n    });\n  });\n\n  for (var o, r = [], i = de(t.groupOffsetTree, e[0].index, e[e.length - 1].index), l = void 0, a = 0, u = W(e); !(o = u()).done;) {\n    var s = o.value;\n    (!l || l.end < s.index) && (l = i.shift(), a = t.groupIndices.indexOf(l.start)), r.push(M({}, s.index === l.start ? {\n      type: \"group\",\n      index: a\n    } : {\n      index: s.index - (a + 1) + n,\n      groupIndex: a\n    }, {\n      size: s.size,\n      offset: s.offset,\n      originalIndex: s.index,\n      data: s.data\n    }));\n  }\n\n  return r;\n}\n\nfunction rt(e, t, n, o, r) {\n  var i = 0,\n      l = 0;\n\n  if (e.length > 0) {\n    i = e[0].offset;\n    var a = e[e.length - 1];\n    l = a.offset + a.size;\n  }\n\n  var u = i,\n      s = o.lastOffset + (n - o.lastIndex) * o.lastSize - l;\n  return {\n    items: ot(e, o, r),\n    topItems: ot(t, o, r),\n    topListHeight: t.reduce(function (e, t) {\n      return t.size + e;\n    }, 0),\n    offsetTop: i,\n    offsetBottom: s,\n    top: u,\n    bottom: l,\n    totalCount: n\n  };\n}\n\nvar it,\n    lt,\n    at,\n    ut = t(function (e) {\n  var t = e[0],\n      a = t.sizes,\n      d = t.totalCount,\n      f = t.data,\n      m = t.firstItemIndex,\n      p = e[1],\n      g = e[2],\n      v = g.visibleRange,\n      S = g.listBoundary,\n      x = g.topListHeight,\n      y = e[3],\n      b = y.scrolledToInitialItem,\n      z = y.initialTopMostItemIndex,\n      k = e[4].topListHeight,\n      B = e[5],\n      E = e[6].didMount,\n      L = o([]),\n      P = n();\n  r(p.topItemsIndexes, L);\n  var O = I(i(C(E, h(v), h(d), h(a), h(z), b, h(L), h(m), f), s(function (e) {\n    return e[0];\n  }), l(function (e) {\n    var t = e[1],\n        n = t[0],\n        o = t[1],\n        r = e[2],\n        i = e[4],\n        l = e[5],\n        a = e[6],\n        u = e[7],\n        s = e[8],\n        c = e[3],\n        d = c.sizeTree,\n        f = c.offsetTree;\n    if (0 === r || 0 === n && 0 === o) return nt;\n    if (X(d)) return rt(function (e, t, n) {\n      if (be(t)) {\n        var o = ye(e, t);\n        return [{\n          index: ne(t.groupOffsetTree, o)[0],\n          size: 0,\n          offset: 0\n        }, {\n          index: o,\n          size: 0,\n          offset: 0,\n          data: n && n[0]\n        }];\n      }\n\n      return [{\n        index: e,\n        size: 0,\n        offset: 0,\n        data: n && n[0]\n      }];\n    }(i, c, s), [], r, c, u);\n    var m = [];\n    if (a.length > 0) for (var h, p = a[0], g = a[a.length - 1], v = 0, I = W(de(d, p, g)); !(h = I()).done;) for (var C = h.value, S = C.value, x = Math.max(C.start, p), T = Math.min(C.end, g), w = x; w <= T; w++) m.push({\n      index: w,\n      size: S,\n      offset: v,\n      data: s && s[w]\n    }), v += S;\n    if (!l) return rt([], m, r, c, u);\n\n    var y = a.length > 0 ? a[a.length - 1] + 1 : 0,\n        b = function (e, t, n, o) {\n      return void 0 === o && (o = 0), o > 0 && (t = Math.max(t, ge(e, o, Ce).offset)), fe((i = n, a = pe(r = e, t, l = Se), u = pe(r, i, l, a), r.slice(a, u + 1)), xe);\n      var r, i, l, a, u;\n    }(f, n, o, y);\n\n    if (0 === b.length) return null;\n    var H = r - 1;\n    return rt(R([], function (e) {\n      for (var t, r = W(b); !(t = r()).done;) {\n        var i = t.value,\n            l = i.value,\n            a = l.offset,\n            u = i.start,\n            c = l.size;\n        l.offset < n && (a += ((u += Math.floor((n - l.offset) / c)) - i.start) * c), u < y && (a += (y - u) * c, u = y);\n\n        for (var d = Math.min(i.end, H), f = u; f <= d && !(a >= o); f++) e.push({\n          index: f,\n          size: c,\n          offset: a,\n          data: s && s[f]\n        }), a += c;\n      }\n    }), m, r, c, u);\n  }), s(function (e) {\n    return null !== e;\n  }), c()), nt);\n  return r(i(f, s(function (e) {\n    return void 0 !== e;\n  }), l(function (e) {\n    return e.length;\n  })), d), r(i(O, l(H(\"topListHeight\"))), k), r(k, x), r(i(O, l(function (e) {\n    return [e.top, e.bottom];\n  })), S), r(i(O, l(function (e) {\n    return e.items;\n  })), P), M({\n    listState: O,\n    topItemsIndexes: L,\n    endReached: u(i(O, s(function (e) {\n      return e.items.length > 0;\n    }), w(d, f), s(function (e) {\n      var t = e[0].items;\n      return t[t.length - 1].originalIndex === e[1] - 1;\n    }), l(function (e) {\n      return [e[1] - 1, e[2]];\n    }), c(D), l(function (e) {\n      return e[0];\n    }))),\n    startReached: u(i(O, T(200), s(function (e) {\n      var t = e.items;\n      return t.length > 0 && t[0].originalIndex === e.topItems.length;\n    }), l(function (e) {\n      return e.items[0].index;\n    }), c())),\n    rangeChanged: u(i(O, s(function (e) {\n      return e.items.length > 0;\n    }), l(function (e) {\n      var t = e.items;\n      return {\n        startIndex: t[0].index,\n        endIndex: t[t.length - 1].index\n      };\n    }), c(F))),\n    itemsRendered: P\n  }, B);\n}, f(Re, tt, Pe, $e, Be, q, K), {\n  singleton: !0\n}),\n    st = t(function (e) {\n  var t = e[0],\n      n = t.sizes,\n      a = t.firstItemIndex,\n      u = t.data,\n      c = e[1].listState,\n      d = e[2].didMount,\n      f = o(0);\n  return r(i(d, w(f), s(function (e) {\n    return 0 !== e[1];\n  }), w(n, a, u), l(function (e) {\n    var t = e[0][1],\n        n = e[1],\n        o = e[2],\n        r = e[3],\n        i = void 0 === r ? [] : r,\n        l = 0;\n    if (n.groupIndices.length > 0) for (var a, u = W(n.groupIndices); !((a = u()).done || a.value - l >= t);) l++;\n    var s = t + l;\n    return rt(Array.from({\n      length: s\n    }).map(function (e, t) {\n      return {\n        index: t,\n        size: 0,\n        offset: 0,\n        data: i[t]\n      };\n    }), [], s, n, o);\n  })), c), {\n    initialItemCount: f\n  };\n}, f(Re, ut, K), {\n  singleton: !0\n}),\n    ct = t(function (e) {\n  var t = e[0].topItemsIndexes,\n      n = o(0);\n  return r(i(n, s(function (e) {\n    return e > 0;\n  }), l(function (e) {\n    return Array.from({\n      length: e\n    }).map(function (e, t) {\n      return t;\n    });\n  })), t), {\n    topItemCount: n\n  };\n}, f(ut)),\n    dt = t(function (e) {\n  var t = e[0],\n      o = t.footerHeight,\n      a = t.headerHeight,\n      u = e[1].listState,\n      s = n(),\n      c = I(i(C(o, a, u), l(function (e) {\n    var t = e[2];\n    return e[0] + e[1] + t.offsetBottom + t.bottom;\n  })), 0);\n  return r(h(c), s), {\n    totalListHeight: c,\n    totalListHeightChanged: s\n  };\n}, f(U, ut), {\n  singleton: !0\n}),\n    ft = t(function (e) {\n  var t = e[0],\n      n = t.scrollBy,\n      o = t.scrollTop,\n      a = t.deviation,\n      c = t.scrollingInProgress,\n      f = e[1],\n      m = f.isScrolling,\n      h = f.isAtBottom,\n      p = f.atBottomState,\n      g = f.scrollDirection,\n      v = e[3],\n      y = v.beforeUnshiftWith,\n      b = v.sizes,\n      H = e[4].log,\n      R = u(i(e[2].listState, w(f.lastJumpDueToItemResize), S(function (e, t) {\n    var n = e[1],\n        o = t[0],\n        r = o.items,\n        i = o.totalCount,\n        l = t[1],\n        a = 0;\n\n    if (e[2] === i) {\n      if (n.length > 0 && r.length > 0) {\n        var u = 1 === r.length;\n        if (0 !== r[0].originalIndex || 0 !== n[0].originalIndex) for (var s = function (e) {\n          var t = r[e],\n              o = n.find(function (e) {\n            return e.originalIndex === t.originalIndex;\n          });\n          return o ? t.offset !== o.offset || u ? (a = t.offset - o.offset + t.size - o.size, \"break\") : void 0 : \"continue\";\n        }, c = r.length - 1; c >= 0; c--) {\n          var d = s(c);\n          if (\"continue\" !== d && \"break\" === d) break;\n        }\n      }\n\n      0 !== a && (a += l);\n    }\n\n    return [a, r, i];\n  }, [0, [], 0]), s(function (e) {\n    return 0 !== e[0];\n  }), w(o, g, c, H, h, p), s(function (e) {\n    return !e[3] && 0 !== e[1] && e[2] === Y;\n  }), l(function (e) {\n    var t = e[0][0];\n    return (0, e[4])(\"Upward scrolling compensation\", {\n      amount: t\n    }, N.DEBUG), t;\n  })));\n  return r(i(R, w(a), l(function (e) {\n    return e[1] - e[0];\n  })), a), d(i(C(I(m, !1), a), s(function (e) {\n    return !e[0] && 0 !== e[1];\n  }), l(function (e) {\n    return e[1];\n  }), T(1)), function (e) {\n    e > 0 ? (x(n, {\n      top: -e,\n      behavior: \"auto\"\n    }), x(a, 0)) : (x(a, 0), x(n, {\n      top: -e,\n      behavior: \"auto\"\n    }));\n  }), r(i(y, w(b), l(function (e) {\n    return e[0] * e[1].lastSize;\n  })), R), {\n    deviation: a\n  };\n}, f(U, q, ut, Re, j)),\n    mt = t(function (e) {\n  var t = e[0].totalListHeight,\n      n = e[1].didMount,\n      r = e[2].scrollTo,\n      a = o(0);\n  return d(i(n, w(a), s(function (e) {\n    return 0 !== e[1];\n  }), l(function (e) {\n    return {\n      top: e[1]\n    };\n  })), function (e) {\n    y(i(t, s(function (e) {\n      return 0 !== e;\n    })), function () {\n      setTimeout(function () {\n        x(r, e);\n      });\n    });\n  }), {\n    initialScrollTop: a\n  };\n}, f(dt, K, U), {\n  singleton: !0\n}),\n    ht = t(function (e) {\n  var t = e[0].viewportHeight,\n      n = e[1].totalListHeight,\n      r = o(!1);\n  return {\n    alignToBottom: r,\n    paddingTopAddition: I(i(C(r, t, n), s(function (e) {\n      return e[0];\n    }), l(function (e) {\n      return Math.max(0, e[1] - e[2]);\n    }), c()), 0)\n  };\n}, f(U, dt), {\n  singleton: !0\n}),\n    pt = t(function (e) {\n  var t = e[0],\n      o = t.sizes,\n      a = t.totalCount,\n      u = e[1],\n      c = u.scrollTop,\n      d = u.viewportHeight,\n      f = u.headerHeight,\n      m = u.scrollingInProgress,\n      h = e[2].scrollToIndex,\n      g = n();\n  return r(i(g, w(o, d, a, f, c), l(function (e) {\n    var t = e[0],\n        n = t.index,\n        o = t.behavior,\n        r = void 0 === o ? \"auto\" : o,\n        l = t.done,\n        a = e[1],\n        u = e[2],\n        c = e[4],\n        d = e[5],\n        f = e[3] - 1,\n        h = null;\n    n = ye(n, a);\n    var g = we(n = Math.max(0, n, Math.min(f, n)), a.offsetTree) + c;\n    return g < d ? h = {\n      index: n,\n      behavior: r,\n      align: \"start\"\n    } : g + ne(a.sizeTree, n)[1] > d + u && (h = {\n      index: n,\n      behavior: r,\n      align: \"end\"\n    }), h ? l && y(i(m, p(1), s(function (e) {\n      return !1 === e;\n    })), l) : l && l(), h;\n  }), s(function (e) {\n    return null !== e;\n  })), h), {\n    scrollIntoView: g\n  };\n}, f(Re, U, Be, ut, j), {\n  singleton: !0\n}),\n    gt = t(function (e) {\n  return M({}, e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);\n}, f(Pe, st, K, J, dt, mt, ht, Oe, pt)),\n    vt = t(function (e) {\n  var t = e[0],\n      n = t.totalCount,\n      o = t.sizeRanges,\n      a = t.fixedItemSize,\n      u = t.defaultItemSize,\n      s = t.trackItemSizes,\n      c = t.itemSize,\n      d = t.data,\n      f = t.firstItemIndex,\n      m = t.groupIndices,\n      h = t.statefulTotalCount,\n      p = e[1],\n      g = p.initialTopMostItemIndex,\n      v = p.scrolledToInitialItem,\n      I = e[2],\n      C = e[3],\n      S = e[4],\n      x = S.listState,\n      T = S.topItemsIndexes,\n      w = A(S, [\"listState\", \"topItemsIndexes\"]),\n      y = e[5].scrollToIndex,\n      b = e[7].topItemCount,\n      R = e[8].groupCounts,\n      z = e[9],\n      k = e[10];\n  return r(w.rangeChanged, z.scrollSeekRangeChanged), r(i(z.windowViewportRect, l(H(\"visibleHeight\"))), I.viewportHeight), M({\n    totalCount: n,\n    data: d,\n    firstItemIndex: f,\n    sizeRanges: o,\n    initialTopMostItemIndex: g,\n    scrolledToInitialItem: v,\n    topItemsIndexes: T,\n    topItemCount: b,\n    groupCounts: R,\n    fixedItemHeight: a,\n    defaultItemHeight: u\n  }, C, {\n    statefulTotalCount: h,\n    listState: x,\n    scrollToIndex: y,\n    trackItemSizes: s,\n    itemSize: c,\n    groupIndices: m\n  }, w, z, I, k);\n}, f(Re, $e, U, Xe, ut, Be, ft, ct, tt, gt, j)),\n    It = (it = function () {\n  if (\"undefined\" == typeof document) return \"sticky\";\n  var e = document.createElement(\"div\");\n  return e.style.position = \"-webkit-sticky\", \"-webkit-sticky\" === e.style.position ? \"-webkit-sticky\" : \"sticky\";\n}, at = !1, function () {\n  return at || (at = !0, lt = it()), lt;\n});\n\nfunction Ct(e) {\n  return e;\n}\n\nvar St = t(function () {\n  var e = o(function (e) {\n    return \"Item \" + e;\n  }),\n      t = o(null),\n      n = o(function (e) {\n    return \"Group \" + e;\n  }),\n      r = o({}),\n      a = o(Ct),\n      u = o(\"div\"),\n      s = o(b),\n      d = function (e, t) {\n    return void 0 === t && (t = null), I(i(r, l(function (t) {\n      return t[e];\n    }), c()), t);\n  };\n\n  return {\n    context: t,\n    itemContent: e,\n    groupContent: n,\n    components: r,\n    computeItemKey: a,\n    headerFooterTag: u,\n    scrollerRef: s,\n    FooterComponent: d(\"Footer\"),\n    HeaderComponent: d(\"Header\"),\n    TopItemListComponent: d(\"TopItemList\"),\n    ListComponent: d(\"List\", \"div\"),\n    ItemComponent: d(\"Item\", \"div\"),\n    GroupComponent: d(\"Group\", \"div\"),\n    ScrollerComponent: d(\"Scroller\", \"div\"),\n    EmptyPlaceholder: d(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: d(\"ScrollSeekPlaceholder\")\n  };\n});\n\nfunction xt(e, t) {\n  var o = n();\n  return d(o, function () {\n    return console.warn(\"react-virtuoso: You are using a deprecated property. \" + t, \"color: red;\", \"color: inherit;\", \"color: blue;\");\n  }), r(o, e), o;\n}\n\nvar Tt = t(function (e) {\n  var t = e[0],\n      o = e[1],\n      u = {\n    item: xt(o.itemContent, \"Rename the %citem%c prop to %citemContent.\"),\n    group: xt(o.groupContent, \"Rename the %cgroup%c prop to %cgroupContent.\"),\n    topItems: xt(t.topItemCount, \"Rename the %ctopItems%c prop to %ctopItemCount.\"),\n    itemHeight: xt(t.fixedItemHeight, \"Rename the %citemHeight%c prop to %cfixedItemHeight.\"),\n    scrollingStateChange: xt(t.isScrolling, \"Rename the %cscrollingStateChange%c prop to %cisScrolling.\"),\n    adjustForPrependedItems: n(),\n    maxHeightCacheSize: n(),\n    footer: n(),\n    header: n(),\n    HeaderContainer: n(),\n    FooterContainer: n(),\n    ItemContainer: n(),\n    ScrollContainer: n(),\n    GroupContainer: n(),\n    ListContainer: n(),\n    emptyComponent: n(),\n    scrollSeek: n()\n  };\n\n  function s(e, t, n) {\n    r(i(e, w(o.components), l(function (e) {\n      var o,\n          r = e[0],\n          i = e[1];\n      return console.warn(\"react-virtuoso: \" + n + \" property is deprecated. Pass components.\" + t + \" instead.\"), M({}, i, ((o = {})[t] = r, o));\n    })), o.components);\n  }\n\n  return d(u.adjustForPrependedItems, function () {\n    console.warn(\"react-virtuoso: adjustForPrependedItems is no longer supported. Use the firstItemIndex property instead - https://virtuoso.dev/prepend-items.\", \"color: red;\", \"color: inherit;\", \"color: blue;\");\n  }), d(u.maxHeightCacheSize, function () {\n    console.warn(\"react-virtuoso: maxHeightCacheSize is no longer necessary. Setting it has no effect - remove it from your code.\");\n  }), d(u.HeaderContainer, function () {\n    console.warn(\"react-virtuoso: HeaderContainer is deprecated. Use headerFooterTag if you want to change the wrapper of the header component and pass components.Header to change its contents.\");\n  }), d(u.FooterContainer, function () {\n    console.warn(\"react-virtuoso: FooterContainer is deprecated. Use headerFooterTag if you want to change the wrapper of the footer component and pass components.Footer to change its contents.\");\n  }), d(u.scrollSeek, function (e) {\n    var n = e.placeholder,\n        r = A(e, [\"placeholder\"]);\n    console.warn(\"react-virtuoso: scrollSeek property is deprecated. Pass scrollSeekConfiguration and specify the placeholder in components.ScrollSeekPlaceholder instead.\"), x(o.components, M({}, a(o.components), {\n      ScrollSeekPlaceholder: n\n    })), x(t.scrollSeekConfiguration, r);\n  }), s(u.footer, \"Footer\", \"footer\"), s(u.header, \"Header\", \"header\"), s(u.ItemContainer, \"Item\", \"ItemContainer\"), s(u.ListContainer, \"List\", \"ListContainer\"), s(u.ScrollContainer, \"Scroller\", \"ScrollContainer\"), s(u.emptyComponent, \"EmptyPlaceholder\", \"emptyComponent\"), s(u.GroupContainer, \"Group\", \"GroupContainer\"), M({}, t, o, u);\n}, f(vt, St)),\n    wt = function (e) {\n  return O(\"div\", {\n    style: {\n      height: e.height\n    }\n  });\n},\n    yt = {\n  position: It(),\n  zIndex: 1,\n  overflowAnchor: \"none\"\n},\n    bt = P(function (e) {\n  var t = e.showTopList,\n      n = void 0 !== t && t,\n      o = Ft(\"listState\"),\n      r = Ft(\"deviation\"),\n      i = Dt(\"sizeRanges\"),\n      l = Ft(\"useWindowScroll\"),\n      a = Ft(\"customScrollParent\"),\n      u = Dt(\"windowScrollContainerState\"),\n      s = Dt(\"scrollContainerState\"),\n      c = a || l ? u : s,\n      d = Ft(\"itemContent\"),\n      f = Ft(\"context\"),\n      m = Ft(\"groupContent\"),\n      h = Ft(\"trackItemSizes\"),\n      p = Ft(\"itemSize\"),\n      g = Ft(\"log\"),\n      v = qe(i, p, h, n ? b : c, g, a),\n      I = Ft(\"EmptyPlaceholder\"),\n      C = Ft(\"ScrollSeekPlaceholder\") || wt,\n      S = Ft(\"ListComponent\"),\n      x = Ft(\"ItemComponent\"),\n      T = Ft(\"GroupComponent\"),\n      w = Ft(\"computeItemKey\"),\n      y = Ft(\"isSeeking\"),\n      H = Ft(\"groupIndices\").length > 0,\n      R = Ft(\"paddingTopAddition\"),\n      z = Ft(\"firstItemIndex\"),\n      k = Ft(\"statefulTotalCount\"),\n      B = n ? {} : {\n    boxSizing: \"border-box\",\n    paddingTop: o.offsetTop + R,\n    paddingBottom: o.offsetBottom,\n    marginTop: r\n  };\n  return !n && 0 === k && I ? O(I, kt(I, f)) : O(S, M({}, kt(S, f), {\n    ref: v,\n    style: B,\n    \"data-test-id\": n ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\"\n  }), (n ? o.topItems : o.items).map(function (e) {\n    var t = e.originalIndex,\n        n = w(t + z, e.data, f);\n    return y ? O(C, M({}, kt(C, f), {\n      key: n,\n      index: e.index,\n      height: e.size,\n      type: e.type || \"item\"\n    }, \"group\" === e.type ? {} : {\n      groupIndex: e.groupIndex\n    })) : \"group\" === e.type ? O(T, M({}, kt(T, f), {\n      key: n,\n      \"data-index\": t,\n      \"data-known-size\": e.size,\n      \"data-item-index\": e.index,\n      style: yt\n    }), m(e.index)) : O(x, M({}, kt(x, f), {\n      key: n,\n      \"data-index\": t,\n      \"data-known-size\": e.size,\n      \"data-item-index\": e.index,\n      \"data-item-group-index\": e.groupIndex,\n      style: {\n        overflowAnchor: \"none\"\n      }\n    }), H ? d(e.index, e.groupIndex, e.data, f) : d(e.index, e.data, f));\n  }));\n}),\n    Ht = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n},\n    Rt = {\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0\n},\n    zt = {\n  width: \"100%\",\n  position: It(),\n  top: 0\n};\n\nfunction kt(e, t) {\n  if (\"string\" != typeof e) return {\n    context: t\n  };\n}\n\nvar Bt = P(function () {\n  var e = Ft(\"HeaderComponent\"),\n      t = Dt(\"headerHeight\"),\n      n = Ft(\"headerFooterTag\"),\n      o = Ke(function (e) {\n    return t(ve(e, \"height\"));\n  }),\n      r = Ft(\"context\");\n  return e ? O(n, {\n    ref: o\n  }, O(e, kt(e, r))) : null;\n}),\n    Et = P(function () {\n  var e = Ft(\"FooterComponent\"),\n      t = Dt(\"footerHeight\"),\n      n = Ft(\"headerFooterTag\"),\n      o = Ke(function (e) {\n    return t(ve(e, \"height\"));\n  }),\n      r = Ft(\"context\");\n  return e ? O(n, {\n    ref: o\n  }, O(e, kt(e, r))) : null;\n});\n\nfunction Lt(e) {\n  var t = e.usePublisher,\n      n = e.useEmitter,\n      o = e.useEmitterValue;\n  return P(function (e) {\n    var r = e.style,\n        i = e.children,\n        l = A(e, [\"style\", \"children\"]),\n        a = t(\"scrollContainerState\"),\n        u = o(\"ScrollerComponent\"),\n        s = t(\"smoothScrollTargetReached\"),\n        c = o(\"scrollerRef\"),\n        d = o(\"context\"),\n        f = Je(a, s, u, c),\n        m = f.scrollerRef,\n        h = f.scrollByCallback;\n    return n(\"scrollTo\", f.scrollToCallback), n(\"scrollBy\", h), O(u, M({\n      ref: m,\n      style: M({}, Ht, r),\n      \"data-test-id\": \"virtuoso-scroller\",\n      \"data-virtuoso-scroller\": !0,\n      tabIndex: 0\n    }, l, kt(u, d)), i);\n  });\n}\n\nfunction Pt(e) {\n  var t = e.usePublisher,\n      n = e.useEmitter,\n      o = e.useEmitterValue;\n  return P(function (e) {\n    var r = e.style,\n        i = e.children,\n        l = A(e, [\"style\", \"children\"]),\n        a = t(\"windowScrollContainerState\"),\n        u = o(\"ScrollerComponent\"),\n        s = t(\"smoothScrollTargetReached\"),\n        c = o(\"totalListHeight\"),\n        d = o(\"deviation\"),\n        f = o(\"customScrollParent\"),\n        m = o(\"context\"),\n        h = Je(a, s, u, b, f),\n        p = h.scrollerRef,\n        g = h.scrollByCallback,\n        v = h.scrollToCallback;\n    return Ze(function () {\n      return p.current = f || window, function () {\n        p.current = null;\n      };\n    }, [p, f]), n(\"windowScrollTo\", v), n(\"scrollBy\", g), O(u, M({\n      style: M({\n        position: \"relative\"\n      }, r, 0 !== c ? {\n        height: c + d\n      } : {}),\n      \"data-virtuoso-scroller\": !0\n    }, l, kt(u, m)), i);\n  });\n}\n\nvar Ot = function (e) {\n  var t = e.children,\n      n = Dt(\"viewportHeight\"),\n      o = Ke(z(n, function (e) {\n    return ve(e, \"height\");\n  }));\n  return O(\"div\", {\n    style: Rt,\n    ref: o,\n    \"data-viewport-type\": \"element\"\n  }, t);\n},\n    Mt = function (e) {\n  var t = e.children,\n      n = Ye(Dt(\"windowViewportRect\"), Ft(\"customScrollParent\"));\n  return O(\"div\", {\n    ref: n,\n    style: Rt,\n    \"data-viewport-type\": \"window\"\n  }, t);\n},\n    At = function (e) {\n  var t = e.children,\n      n = Ft(\"TopItemListComponent\"),\n      o = Ft(\"headerHeight\"),\n      r = M({}, zt, {\n    marginTop: o + \"px\"\n  }),\n      i = Ft(\"context\");\n  return O(n || \"div\", {\n    style: r,\n    context: i\n  }, t);\n},\n    Vt = e(Tt, {\n  required: {},\n  optional: {\n    context: \"context\",\n    followOutput: \"followOutput\",\n    firstItemIndex: \"firstItemIndex\",\n    itemContent: \"itemContent\",\n    groupContent: \"groupContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    topItemCount: \"topItemCount\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    groupCounts: \"groupCounts\",\n    atBottomThreshold: \"atBottomThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    headerFooterTag: \"headerFooterTag\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\",\n    item: \"item\",\n    group: \"group\",\n    topItems: \"topItems\",\n    itemHeight: \"itemHeight\",\n    scrollingStateChange: \"scrollingStateChange\",\n    maxHeightCacheSize: \"maxHeightCacheSize\",\n    footer: \"footer\",\n    header: \"header\",\n    ItemContainer: \"ItemContainer\",\n    ScrollContainer: \"ScrollContainer\",\n    ListContainer: \"ListContainer\",\n    GroupContainer: \"GroupContainer\",\n    emptyComponent: \"emptyComponent\",\n    HeaderContainer: \"HeaderContainer\",\n    FooterContainer: \"FooterContainer\",\n    scrollSeek: \"scrollSeek\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    adjustForPrependedItems: \"adjustForPrependedItems\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, P(function (e) {\n  var t = Ft(\"useWindowScroll\"),\n      n = Ft(\"topItemsIndexes\").length > 0,\n      o = Ft(\"customScrollParent\"),\n      r = o || t ? Mt : Ot;\n  return O(o || t ? Ut : Nt, M({}, e), O(r, null, O(Bt, null), O(bt, null), O(Et, null)), n && O(At, null, O(bt, {\n    showTopList: !0\n  })));\n})),\n    Wt = Vt.Component,\n    Dt = Vt.usePublisher,\n    Ft = Vt.useEmitterValue,\n    Gt = Vt.useEmitter,\n    Nt = Lt({\n  usePublisher: Dt,\n  useEmitterValue: Ft,\n  useEmitter: Gt\n}),\n    Ut = Pt({\n  usePublisher: Dt,\n  useEmitterValue: Ft,\n  useEmitter: Gt\n}),\n    _t = t(function () {\n  var e = o(function (e) {\n    return \"Item \" + e;\n  }),\n      t = o({}),\n      n = o(null),\n      r = o(\"virtuoso-grid-item\"),\n      a = o(\"virtuoso-grid-list\"),\n      u = o(Ct),\n      s = o(b),\n      d = function (e, n) {\n    return void 0 === n && (n = null), I(i(t, l(function (t) {\n      return t[e];\n    }), c()), n);\n  };\n\n  return {\n    context: n,\n    itemContent: e,\n    components: t,\n    computeItemKey: u,\n    itemClassName: r,\n    listClassName: a,\n    scrollerRef: s,\n    ListComponent: d(\"List\", \"div\"),\n    ItemComponent: d(\"Item\", \"div\"),\n    ScrollerComponent: d(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: d(\"ScrollSeekPlaceholder\", \"div\")\n  };\n}),\n    jt = t(function (e) {\n  var t = e[0],\n      o = e[1],\n      u = {\n    item: xt(o.itemContent, \"Rename the %citem%c prop to %citemContent.\"),\n    ItemContainer: n(),\n    ScrollContainer: n(),\n    ListContainer: n(),\n    emptyComponent: n(),\n    scrollSeek: n()\n  };\n\n  function s(e, t, n) {\n    r(i(e, w(o.components), l(function (e) {\n      var o,\n          r = e[0],\n          i = e[1];\n      return console.warn(\"react-virtuoso: \" + n + \" property is deprecated. Pass components.\" + t + \" instead.\"), M({}, i, ((o = {})[t] = r, o));\n    })), o.components);\n  }\n\n  return d(u.scrollSeek, function (e) {\n    var n = e.placeholder,\n        r = A(e, [\"placeholder\"]);\n    console.warn(\"react-virtuoso: scrollSeek property is deprecated. Pass scrollSeekConfiguration and specify the placeholder in components.ScrollSeekPlaceholder instead.\"), x(o.components, M({}, a(o.components), {\n      ScrollSeekPlaceholder: n\n    })), x(t.scrollSeekConfiguration, r);\n  }), s(u.ItemContainer, \"Item\", \"ItemContainer\"), s(u.ListContainer, \"List\", \"ListContainer\"), s(u.ScrollContainer, \"Scroller\", \"ScrollContainer\"), M({}, t, o, u);\n}, f(Ne, _t)),\n    Kt = P(function () {\n  var e = Qt(\"gridState\"),\n      t = Qt(\"listClassName\"),\n      n = Qt(\"itemClassName\"),\n      o = Qt(\"itemContent\"),\n      r = Qt(\"computeItemKey\"),\n      i = Qt(\"isSeeking\"),\n      l = $t(\"scrollHeight\"),\n      a = Qt(\"ItemComponent\"),\n      u = Qt(\"ListComponent\"),\n      s = Qt(\"ScrollSeekPlaceholder\"),\n      c = Qt(\"context\"),\n      d = $t(\"itemDimensions\"),\n      f = Ke(function (e) {\n    l(e.parentElement.parentElement.scrollHeight);\n    var t = e.firstChild;\n    t && d(t.getBoundingClientRect());\n  });\n  return O(u, M({\n    ref: f,\n    className: t\n  }, kt(u, c), {\n    style: {\n      paddingTop: e.offsetTop,\n      paddingBottom: e.offsetBottom\n    }\n  }), e.items.map(function (t) {\n    var l = r(t.index);\n    return i ? O(s, M({\n      key: l\n    }, kt(s, c), {\n      index: t.index,\n      height: e.itemHeight,\n      width: e.itemWidth\n    })) : O(a, M({}, kt(a, c), {\n      className: n,\n      \"data-index\": t.index,\n      key: l\n    }), o(t.index, c));\n  }));\n}),\n    Yt = function (e) {\n  var t = e.children,\n      n = $t(\"viewportDimensions\"),\n      o = Ke(function (e) {\n    n(e.getBoundingClientRect());\n  });\n  return O(\"div\", {\n    style: Rt,\n    ref: o\n  }, t);\n},\n    Zt = function (e) {\n  var t = e.children,\n      n = Ye($t(\"windowViewportRect\"), Qt(\"customScrollParent\"));\n  return O(\"div\", {\n    ref: n,\n    style: Rt\n  }, t);\n},\n    qt = e(jt, {\n  optional: {\n    totalCount: \"totalCount\",\n    overscan: \"overscan\",\n    itemContent: \"itemContent\",\n    components: \"components\",\n    computeItemKey: \"computeItemKey\",\n    initialItemCount: \"initialItemCount\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    listClassName: \"listClassName\",\n    itemClassName: \"itemClassName\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    item: \"item\",\n    ItemContainer: \"ItemContainer\",\n    ScrollContainer: \"ScrollContainer\",\n    ListContainer: \"ListContainer\",\n    scrollSeek: \"scrollSeek\"\n  },\n  methods: {\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    scrollToIndex: \"scrollToIndex\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\"\n  }\n}, P(function (e) {\n  var t = M({}, e),\n      n = Qt(\"useWindowScroll\"),\n      o = Qt(\"customScrollParent\"),\n      r = o || n ? Zt : Yt;\n  return O(o || n ? tn : en, M({}, t), O(r, null, O(Kt, null)));\n})),\n    Jt = qt.Component,\n    $t = qt.usePublisher,\n    Qt = qt.useEmitterValue,\n    Xt = qt.useEmitter,\n    en = Lt({\n  usePublisher: $t,\n  useEmitterValue: Qt,\n  useEmitter: Xt\n}),\n    tn = Pt({\n  usePublisher: $t,\n  useEmitterValue: Qt,\n  useEmitter: Xt\n}),\n    nn = t(function () {\n  var e = o(function (e) {\n    return O(\"td\", null, \"Item $\", e);\n  }),\n      t = o(null),\n      n = o(null),\n      r = o({}),\n      a = o(Ct),\n      u = o(b),\n      s = function (e, t) {\n    return void 0 === t && (t = null), I(i(r, l(function (t) {\n      return t[e];\n    }), c()), t);\n  };\n\n  return {\n    context: t,\n    itemContent: e,\n    fixedHeaderContent: n,\n    components: r,\n    computeItemKey: a,\n    scrollerRef: u,\n    TableComponent: s(\"Table\", \"table\"),\n    TableHeadComponent: s(\"TableHead\", \"thead\"),\n    TableBodyComponent: s(\"TableBody\", \"tbody\"),\n    TableRowComponent: s(\"TableRow\", \"tr\"),\n    ScrollerComponent: s(\"Scroller\", \"div\"),\n    EmptyPlaceholder: s(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: s(\"ScrollSeekPlaceholder\")\n  };\n}),\n    on = t(function (e) {\n  return M({}, e[0], e[1]);\n}, f(vt, nn)),\n    rn = function (e) {\n  return O(\"tr\", null, O(\"td\", {\n    style: {\n      height: e.height\n    }\n  }));\n},\n    ln = function (e) {\n  return O(\"tr\", null, O(\"td\", {\n    style: {\n      height: e.height,\n      padding: 0,\n      border: 0\n    }\n  }));\n},\n    an = P(function () {\n  var e = mn(\"listState\"),\n      t = mn(\"deviation\"),\n      n = fn(\"sizeRanges\"),\n      o = mn(\"useWindowScroll\"),\n      r = mn(\"customScrollParent\"),\n      i = fn(\"windowScrollContainerState\"),\n      l = fn(\"scrollContainerState\"),\n      a = r || o ? i : l,\n      u = mn(\"itemContent\"),\n      s = mn(\"trackItemSizes\"),\n      c = qe(n, mn(\"itemSize\"), s, a, mn(\"log\"), r),\n      d = mn(\"EmptyPlaceholder\"),\n      f = mn(\"ScrollSeekPlaceholder\") || rn,\n      m = mn(\"TableBodyComponent\"),\n      h = mn(\"TableRowComponent\"),\n      p = mn(\"computeItemKey\"),\n      g = mn(\"isSeeking\"),\n      v = mn(\"paddingTopAddition\"),\n      I = mn(\"firstItemIndex\"),\n      C = mn(\"statefulTotalCount\"),\n      S = mn(\"context\");\n  if (0 === C && d) return O(d, kt(d, S));\n  var x = e.offsetTop + v + t,\n      T = e.offsetBottom,\n      w = x > 0 ? O(ln, {\n    height: x,\n    key: \"padding-top\"\n  }) : null,\n      y = T > 0 ? O(ln, {\n    height: T,\n    key: \"padding-bottom\"\n  }) : null,\n      b = e.items.map(function (e) {\n    var t = e.originalIndex,\n        n = p(t + I, e.data, S);\n    return g ? O(f, M({}, kt(f, S), {\n      key: n,\n      index: e.index,\n      height: e.size,\n      type: e.type || \"item\"\n    })) : O(h, M({}, kt(h, S), {\n      key: n,\n      \"data-index\": t,\n      \"data-known-size\": e.size,\n      \"data-item-index\": e.index,\n      style: {\n        overflowAnchor: \"none\"\n      }\n    }), u(e.index, e.data, S));\n  });\n  return O(m, M({\n    ref: c,\n    \"data-test-id\": \"virtuoso-item-list\"\n  }, kt(m, S)), [w].concat(b, [y]));\n}),\n    un = function (e) {\n  var t = e.children,\n      n = fn(\"viewportHeight\"),\n      o = Ke(z(n, function (e) {\n    return ve(e, \"height\");\n  }));\n  return O(\"div\", {\n    style: Rt,\n    ref: o,\n    \"data-viewport-type\": \"element\"\n  }, t);\n},\n    sn = function (e) {\n  var t = e.children,\n      n = Ye(fn(\"windowViewportRect\"), mn(\"customScrollParent\"));\n  return O(\"div\", {\n    ref: n,\n    style: Rt,\n    \"data-viewport-type\": \"window\"\n  }, t);\n},\n    cn = e(on, {\n  required: {},\n  optional: {\n    context: \"context\",\n    followOutput: \"followOutput\",\n    firstItemIndex: \"firstItemIndex\",\n    itemContent: \"itemContent\",\n    fixedHeaderContent: \"fixedHeaderContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    topItemCount: \"topItemCount\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    groupCounts: \"groupCounts\",\n    atBottomThreshold: \"atBottomThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, P(function (e) {\n  var t = mn(\"useWindowScroll\"),\n      n = mn(\"customScrollParent\"),\n      o = fn(\"fixedHeaderHeight\"),\n      r = mn(\"fixedHeaderContent\"),\n      i = mn(\"context\"),\n      l = Ke(z(o, function (e) {\n    return ve(e, \"height\");\n  })),\n      a = n || t ? gn : pn,\n      u = n || t ? sn : un,\n      s = mn(\"TableComponent\"),\n      c = mn(\"TableHeadComponent\"),\n      d = r ? O(c, M({\n    key: \"TableHead\",\n    style: {\n      zIndex: 1,\n      position: \"sticky\",\n      top: 0\n    },\n    ref: l\n  }, kt(c, i)), r()) : null;\n  return O(a, M({}, e), O(u, null, O(s, M({\n    style: {\n      borderSpacing: 0\n    }\n  }, kt(s, i)), [d, O(an, {\n    key: \"TableBody\"\n  })])));\n})),\n    dn = cn.Component,\n    fn = cn.usePublisher,\n    mn = cn.useEmitterValue,\n    hn = cn.useEmitter,\n    pn = Lt({\n  usePublisher: fn,\n  useEmitterValue: mn,\n  useEmitter: hn\n}),\n    gn = Pt({\n  usePublisher: fn,\n  useEmitterValue: mn,\n  useEmitter: hn\n}),\n    vn = Wt,\n    In = Wt,\n    Cn = dn,\n    Sn = Jt;\n\nexport { In as GroupedVirtuoso, N as LogLevel, Cn as TableVirtuoso, vn as Virtuoso, Sn as VirtuosoGrid };","map":null,"metadata":{},"sourceType":"module"}