{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { Virtuoso } from 'react-virtuoso';\nimport { GiphyPreviewMessage as DefaultGiphyPreviewMessage } from './GiphyPreviewMessage';\nimport { useGiphyPreview } from './hooks/useGiphyPreview';\nimport { useNewMessageNotification } from './hooks/useNewMessageNotification';\nimport { usePrependedMessagesCount } from './hooks/usePrependMessagesCount';\nimport { useShouldForceScrollToBottom } from './hooks/useShouldForceScrollToBottom';\nimport { MessageNotification as DefaultMessageNotification } from './MessageNotification';\nimport { MessageListNotifications as DefaultMessageListNotifications } from './MessageListNotifications';\nimport { processMessages } from './utils';\nimport { DateSeparator as DefaultDateSeparator } from '../DateSeparator/DateSeparator';\nimport { EmptyStateIndicator as DefaultEmptyStateIndicator } from '../EmptyStateIndicator/EmptyStateIndicator';\nimport { EventComponent } from '../EventComponent/EventComponent';\nimport { LoadingIndicator as DefaultLoadingIndicator } from '../Loading/LoadingIndicator';\nimport { Message, MessageSimple } from '../Message';\nimport { useChannelActionContext } from '../../context/ChannelActionContext';\nimport { useChannelStateContext } from '../../context/ChannelStateContext';\nimport { useChatContext } from '../../context/ChatContext';\nimport { useComponentContext } from '../../context/ComponentContext';\nimport { isDate } from '../../context/TranslationContext';\nvar PREPEND_OFFSET = Math.pow(10, 7);\n\nvar VirtualizedMessageListWithContext = function (props) {\n  var additionalVirtuosoProps = props.additionalVirtuosoProps,\n      channel = props.channel,\n      closeReactionSelectorOnClick = props.closeReactionSelectorOnClick,\n      customMessageRenderer = props.customMessageRenderer,\n      defaultItemHeight = props.defaultItemHeight,\n      _a = props.disableDateSeparator,\n      disableDateSeparator = _a === void 0 ? true : _a,\n      hasMore = props.hasMore,\n      _b = props.hideDeletedMessages,\n      hideDeletedMessages = _b === void 0 ? false : _b,\n      _c = props.hideNewMessageSeparator,\n      hideNewMessageSeparator = _c === void 0 ? false : _c,\n      loadingMore = props.loadingMore,\n      loadMore = props.loadMore,\n      propMessage = props.Message,\n      _d = props.messageLimit,\n      messageLimit = _d === void 0 ? 100 : _d,\n      messages = props.messages,\n      notifications = props.notifications,\n      _e = props.overscan,\n      overscan = _e === void 0 ? 0 : _e,\n      // TODO: refactor to scrollSeekPlaceHolderConfiguration and components.ScrollSeekPlaceholder, like the Virtuoso Component\n  scrollSeekPlaceHolder = props.scrollSeekPlaceHolder,\n      _f = props.scrollToLatestMessageOnFocus,\n      scrollToLatestMessageOnFocus = _f === void 0 ? false : _f,\n      _g = props.separateGiphyPreview,\n      separateGiphyPreview = _g === void 0 ? false : _g,\n      _h = props.shouldGroupByUser,\n      shouldGroupByUser = _h === void 0 ? false : _h,\n      _j = props.stickToBottomScrollBehavior,\n      stickToBottomScrollBehavior = _j === void 0 ? 'smooth' : _j;\n\n  var _k = useComponentContext('VirtualizedMessageList'),\n      _l = _k.DateSeparator,\n      DateSeparator = _l === void 0 ? DefaultDateSeparator : _l,\n      _m = _k.EmptyStateIndicator,\n      EmptyStateIndicator = _m === void 0 ? DefaultEmptyStateIndicator : _m,\n      _o = _k.GiphyPreviewMessage,\n      GiphyPreviewMessage = _o === void 0 ? DefaultGiphyPreviewMessage : _o,\n      _p = _k.LoadingIndicator,\n      LoadingIndicator = _p === void 0 ? DefaultLoadingIndicator : _p,\n      _q = _k.MessageListNotifications,\n      MessageListNotifications = _q === void 0 ? DefaultMessageListNotifications : _q,\n      _r = _k.MessageNotification,\n      MessageNotification = _r === void 0 ? DefaultMessageNotification : _r,\n      _s = _k.MessageSystem,\n      MessageSystem = _s === void 0 ? EventComponent : _s,\n      _t = _k.TypingIndicator,\n      TypingIndicator = _t === void 0 ? null : _t,\n      _u = _k.VirtualMessage,\n      contextMessage = _u === void 0 ? MessageSimple : _u;\n\n  var _v = useChatContext('VirtualizedMessageList'),\n      client = _v.client,\n      customClasses = _v.customClasses;\n\n  var lastRead = useMemo(function () {\n    var _a;\n\n    return (_a = channel.lastRead) === null || _a === void 0 ? void 0 : _a.call(channel);\n  }, [channel]);\n  var MessageUIComponent = propMessage || contextMessage;\n\n  var _w = useGiphyPreview(separateGiphyPreview),\n      giphyPreviewMessage = _w.giphyPreviewMessage,\n      setGiphyPreviewMessage = _w.setGiphyPreviewMessage;\n\n  var processedMessages = useMemo(function () {\n    if (typeof messages === 'undefined') {\n      return [];\n    }\n\n    if (disableDateSeparator && !hideDeletedMessages && hideNewMessageSeparator && !separateGiphyPreview) {\n      return messages;\n    }\n\n    return processMessages({\n      disableDateSeparator: disableDateSeparator,\n      hideDeletedMessages: hideDeletedMessages,\n      hideNewMessageSeparator: hideNewMessageSeparator,\n      lastRead: lastRead,\n      messages: messages,\n      separateGiphyPreview: separateGiphyPreview,\n      setGiphyPreviewMessage: setGiphyPreviewMessage,\n      userId: client.userID || ''\n    });\n  }, [disableDateSeparator, hideDeletedMessages, hideNewMessageSeparator, lastRead, messages, messages === null || messages === void 0 ? void 0 : messages.length, client.userID]);\n  var virtuoso = useRef(null);\n\n  var _x = useNewMessageNotification(processedMessages, client.userID),\n      atBottom = _x.atBottom,\n      newMessagesNotification = _x.newMessagesNotification,\n      setNewMessagesNotification = _x.setNewMessagesNotification;\n\n  var scrollToBottom = useCallback(function () {\n    if (virtuoso.current) {\n      virtuoso.current.scrollToIndex(processedMessages.length - 1);\n    }\n\n    setNewMessagesNotification(false);\n  }, [virtuoso, processedMessages, setNewMessagesNotification, processedMessages.length]);\n  var scrollToBottomIfConfigured = useCallback(function (event) {\n    if (scrollToLatestMessageOnFocus && event.target === window) {\n      setTimeout(scrollToBottom, 100);\n    }\n  }, [scrollToLatestMessageOnFocus, scrollToBottom]);\n  useEffect(function () {\n    if (typeof window !== 'undefined') {\n      window.addEventListener('focus', scrollToBottomIfConfigured);\n    }\n\n    return function () {\n      return window.removeEventListener('focus', scrollToBottomIfConfigured);\n    };\n  }, [scrollToBottomIfConfigured]);\n  var numItemsPrepended = usePrependedMessagesCount(processedMessages);\n  var shouldForceScrollToBottom = useShouldForceScrollToBottom(processedMessages, client.userID);\n\n  var followOutput = function (isAtBottom) {\n    if (shouldForceScrollToBottom()) {\n      return isAtBottom ? stickToBottomScrollBehavior : 'auto';\n    } // a message from another user has been received - don't scroll to bottom unless already there\n\n\n    return isAtBottom ? stickToBottomScrollBehavior : false;\n  };\n\n  var messageRenderer = useCallback(function (messageList, virtuosoIndex) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n\n    var streamMessageIndex = virtuosoIndex + numItemsPrepended - PREPEND_OFFSET; // use custom renderer supplied by client if present and skip the rest\n\n    if (customMessageRenderer) {\n      return customMessageRenderer(messageList, streamMessageIndex);\n    }\n\n    var message = messageList[streamMessageIndex];\n\n    if (message.customType === 'message.date' && message.date && isDate(message.date)) {\n      return React.createElement(DateSeparator, {\n        date: message.date,\n        unread: message.unread\n      });\n    }\n\n    if (!message) return React.createElement(\"div\", {\n      style: {\n        height: '1px'\n      }\n    }); // returning null or zero height breaks the virtuoso\n\n    if (message.type === 'system') {\n      return React.createElement(MessageSystem, {\n        message: message\n      });\n    }\n\n    var groupedByUser = shouldGroupByUser && streamMessageIndex > 0 && ((_a = message.user) === null || _a === void 0 ? void 0 : _a.id) === ((_b = messageList[streamMessageIndex - 1].user) === null || _b === void 0 ? void 0 : _b.id);\n    var firstOfGroup = shouldGroupByUser && ((_c = message.user) === null || _c === void 0 ? void 0 : _c.id) !== ((_e = (_d = messageList[streamMessageIndex - 1]) === null || _d === void 0 ? void 0 : _d.user) === null || _e === void 0 ? void 0 : _e.id);\n    var endOfGroup = shouldGroupByUser && ((_f = message.user) === null || _f === void 0 ? void 0 : _f.id) !== ((_h = (_g = messageList[streamMessageIndex + 1]) === null || _g === void 0 ? void 0 : _g.user) === null || _h === void 0 ? void 0 : _h.id);\n    return React.createElement(Message, {\n      closeReactionSelectorOnClick: closeReactionSelectorOnClick,\n      customMessageActions: props.customMessageActions,\n      endOfGroup: endOfGroup,\n      firstOfGroup: firstOfGroup,\n      groupedByUser: groupedByUser,\n      message: message,\n      Message: MessageUIComponent,\n      messageActions: props.messageActions\n    });\n  }, [customMessageRenderer, shouldGroupByUser, numItemsPrepended]);\n  var virtuosoComponents = useMemo(function () {\n    var EmptyPlaceholder = function () {\n      return React.createElement(React.Fragment, null, EmptyStateIndicator && React.createElement(EmptyStateIndicator, {\n        listType: 'message'\n      }));\n    };\n\n    var Header = function () {\n      return loadingMore ? React.createElement(\"div\", {\n        className: 'str-chat__virtual-list__loading'\n      }, React.createElement(LoadingIndicator, {\n        size: 20\n      })) : React.createElement(React.Fragment, null);\n    };\n\n    var virtualMessageClass = (customClasses === null || customClasses === void 0 ? void 0 : customClasses.virtualMessage) || 'str-chat__virtual-list-message-wrapper'; // using 'display: inline-block' traps CSS margins of the item elements, preventing incorrect item measurements\n\n    var Item = function (props) {\n      return React.createElement(\"div\", __assign({}, props, {\n        className: virtualMessageClass\n      }));\n    };\n\n    var Footer = function () {\n      return TypingIndicator ? React.createElement(TypingIndicator, {\n        avatarSize: 24\n      }) : React.createElement(React.Fragment, null);\n    };\n\n    return {\n      EmptyPlaceholder: EmptyPlaceholder,\n      Footer: Footer,\n      Header: Header,\n      Item: Item\n    };\n  }, [loadingMore]);\n\n  var atBottomStateChange = function (isAtBottom) {\n    atBottom.current = isAtBottom;\n\n    if (isAtBottom && newMessagesNotification) {\n      setNewMessagesNotification(false);\n    }\n  };\n\n  var startReached = function () {\n    if (hasMore && loadMore) {\n      loadMore(messageLimit);\n    }\n  };\n\n  if (!processedMessages) return null;\n  var virtualizedMessageListClass = (customClasses === null || customClasses === void 0 ? void 0 : customClasses.virtualizedMessageList) || 'str-chat__virtual-list';\n  return React.createElement(React.Fragment, null, React.createElement(\"div\", {\n    className: virtualizedMessageListClass\n  }, React.createElement(Virtuoso, __assign({\n    atBottomStateChange: atBottomStateChange,\n    components: virtuosoComponents,\n    firstItemIndex: PREPEND_OFFSET - numItemsPrepended,\n    followOutput: followOutput,\n    initialTopMostItemIndex: processedMessages.length ? processedMessages.length - 1 : 0,\n    itemContent: function (i) {\n      return messageRenderer(processedMessages, i);\n    },\n    overscan: overscan,\n    ref: virtuoso,\n    startReached: startReached,\n    style: {\n      overflowX: 'hidden'\n    },\n    totalCount: processedMessages.length\n  }, additionalVirtuosoProps, scrollSeekPlaceHolder ? {\n    scrollSeek: scrollSeekPlaceHolder\n  } : {}, defaultItemHeight ? {\n    defaultItemHeight: defaultItemHeight\n  } : {}))), React.createElement(MessageListNotifications, {\n    hasNewMessages: newMessagesNotification,\n    MessageNotification: MessageNotification,\n    notifications: notifications,\n    scrollToBottom: scrollToBottom\n  }), giphyPreviewMessage && React.createElement(GiphyPreviewMessage, {\n    message: giphyPreviewMessage\n  }));\n};\n/**\n * The VirtualizedMessageList component renders a list of messages in a virtualized list.\n * It is a consumer of the React contexts set in [Channel](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Channel/Channel.tsx).\n *\n * **Note**: It works well when there are thousands of messages in a channel, it has a shortcoming though - the message UI should have a fixed height.\n */\n\n\nexport function VirtualizedMessageList(props) {\n  var loadMore = useChannelActionContext('VirtualizedMessageList').loadMore;\n\n  var _a = useChannelStateContext('VirtualizedMessageList'),\n      channel = _a.channel,\n      hasMore = _a.hasMore,\n      loadingMore = _a.loadingMore,\n      contextMessages = _a.messages,\n      notifications = _a.notifications;\n\n  var messages = props.messages || contextMessages;\n  return React.createElement(VirtualizedMessageListWithContext, __assign({\n    channel: channel,\n    hasMore: !!hasMore,\n    loadingMore: !!loadingMore,\n    loadMore: loadMore,\n    messages: messages,\n    notifications: notifications\n  }, props));\n}","map":null,"metadata":{},"sourceType":"module"}