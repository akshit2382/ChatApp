{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nexport var channelReducer = function (state, action) {\n  var _a;\n\n  switch (action.type) {\n    case 'closeThread':\n      {\n        return __assign(__assign({}, state), {\n          thread: null,\n          threadLoadingMore: false,\n          threadMessages: []\n        });\n      }\n\n    case 'copyMessagesFromChannel':\n      {\n        var channel = action.channel,\n            parentId = action.parentId;\n        return __assign(__assign({}, state), {\n          messages: __spreadArray([], channel.state.messages),\n          pinnedMessages: __spreadArray([], channel.state.pinnedMessages),\n          threadMessages: parentId ? __assign({}, channel.state.threads)[parentId] || [] : state.threadMessages\n        });\n      }\n\n    case 'copyStateFromChannelOnEvent':\n      {\n        var channel = action.channel;\n        return __assign(__assign({}, state), {\n          members: __assign({}, channel.state.members),\n          messages: __spreadArray([], channel.state.messages),\n          pinnedMessages: __spreadArray([], channel.state.pinnedMessages),\n          read: __assign({}, channel.state.read),\n          watcherCount: channel.state.watcher_count,\n          watchers: __assign({}, channel.state.watchers)\n        });\n      }\n\n    case 'initStateFromChannel':\n      {\n        var channel = action.channel;\n        return __assign(__assign({}, state), {\n          loading: false,\n          members: __assign({}, channel.state.members),\n          messages: __spreadArray([], channel.state.messages),\n          pinnedMessages: __spreadArray([], channel.state.pinnedMessages),\n          read: __assign({}, channel.state.read),\n          watcherCount: channel.state.watcher_count,\n          watchers: __assign({}, channel.state.watchers)\n        });\n      }\n\n    case 'loadMoreFinished':\n      {\n        var hasMore = action.hasMore,\n            messages = action.messages;\n        return __assign(__assign({}, state), {\n          hasMore: hasMore,\n          loadingMore: false,\n          messages: messages\n        });\n      }\n\n    case 'loadMoreThreadFinished':\n      {\n        var threadHasMore = action.threadHasMore,\n            threadMessages = action.threadMessages;\n        return __assign(__assign({}, state), {\n          threadHasMore: threadHasMore,\n          threadLoadingMore: false,\n          threadMessages: threadMessages\n        });\n      }\n\n    case 'openThread':\n      {\n        var channel = action.channel,\n            message = action.message;\n        return __assign(__assign({}, state), {\n          thread: message,\n          threadMessages: message.id ? __assign({}, channel.state.threads)[message.id] || [] : []\n        });\n      }\n\n    case 'setError':\n      {\n        var error = action.error;\n        return __assign(__assign({}, state), {\n          error: error\n        });\n      }\n\n    case 'setLoadingMore':\n      {\n        var loadingMore = action.loadingMore;\n        return __assign(__assign({}, state), {\n          loadingMore: loadingMore\n        });\n      }\n\n    case 'setThread':\n      {\n        var message = action.message;\n        return __assign(__assign({}, state), {\n          thread: message\n        });\n      }\n\n    case 'setTyping':\n      {\n        var channel = action.channel;\n        return __assign(__assign({}, state), {\n          typing: __assign({}, channel.state.typing)\n        });\n      }\n\n    case 'startLoadingThread':\n      {\n        return __assign(__assign({}, state), {\n          threadLoadingMore: true\n        });\n      }\n\n    case 'updateThreadOnEvent':\n      {\n        var channel = action.channel,\n            message = action.message;\n        if (!state.thread) return state;\n        return __assign(__assign({}, state), {\n          thread: (message === null || message === void 0 ? void 0 : message.id) === state.thread.id ? channel.state.formatMessage(message) : state.thread,\n          threadMessages: ((_a = state.thread) === null || _a === void 0 ? void 0 : _a.id) ? __assign({}, channel.state.threads)[state.thread.id] || [] : []\n        });\n      }\n\n    default:\n      return state;\n  }\n};\nexport var initialState = {\n  error: null,\n  hasMore: true,\n  loading: true,\n  loadingMore: false,\n  members: {},\n  messages: [],\n  pinnedMessages: [],\n  read: {},\n  thread: null,\n  threadHasMore: true,\n  threadLoadingMore: false,\n  threadMessages: [],\n  typing: {},\n  watcherCount: 0,\n  watchers: {}\n};","map":null,"metadata":{},"sourceType":"module"}