{"ast":null,"code":"'use strict';\n\nconst ICAL = require('ical.js'); // Copied from https://dxr.mozilla.org/comm-central/source/calendar/timezones/zones.json\n// And compiled using node compile-zones.js\n// See also https://github.com/mozilla-comm/ical.js/issues/195\n\n\nconst timezones = require('./zones-compiled.json');\n\nclass IcalExpander {\n  constructor(opts) {\n    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1000;\n    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;\n    this.jCalData = ICAL.parse(opts.ics);\n    this.component = new ICAL.Component(this.jCalData);\n    this.events = this.component.getAllSubcomponents('vevent').map(vevent => new ICAL.Event(vevent));\n\n    if (this.skipInvalidDates) {\n      this.events = this.events.filter(evt => {\n        try {\n          evt.startDate.toJSDate();\n          evt.endDate.toJSDate();\n          return true;\n        } catch (err) {\n          // skipping events with invalid time\n          return false;\n        }\n      });\n    }\n  }\n\n  between(after, before) {\n    function isEventWithinRange(startTime, endTime) {\n      return (!after || endTime >= after.getTime()) && (!before || startTime <= before.getTime());\n    }\n\n    function getTimes(eventOrOccurrence) {\n      const startTime = eventOrOccurrence.startDate.toJSDate().getTime();\n      let endTime = eventOrOccurrence.endDate.toJSDate().getTime(); // If it is an all day event, the end date is set to 00:00 of the next day\n      // So we need to make it be 23:59:59 to compare correctly with the given range\n\n      if (eventOrOccurrence.endDate.isDate && endTime > startTime) {\n        endTime -= 1;\n      }\n\n      return {\n        startTime,\n        endTime\n      };\n    }\n\n    const exceptions = [];\n    this.events.forEach(event => {\n      if (event.isRecurrenceException()) exceptions.push(event);\n    });\n    const ret = {\n      events: [],\n      occurrences: []\n    };\n    this.events.filter(e => !e.isRecurrenceException()).forEach(event => {\n      const exdates = [];\n      event.component.getAllProperties('exdate').forEach(exdateProp => {\n        const exdate = exdateProp.getFirstValue();\n        exdates.push(exdate.toJSDate().getTime());\n      }); // Recurring event is handled differently\n\n      if (event.isRecurring()) {\n        const iterator = event.iterator();\n        let next;\n        let i = 0;\n\n        do {\n          i += 1;\n          next = iterator.next();\n\n          if (next) {\n            const occurrence = event.getOccurrenceDetails(next);\n\n            const _getTimes = getTimes(occurrence),\n                  startTime = _getTimes.startTime,\n                  endTime = _getTimes.endTime;\n\n            const isOccurrenceExcluded = exdates.indexOf(startTime) !== -1; // TODO check that within same day?\n\n            const exception = exceptions.find(ex => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime()); // We have passed the max date, stop\n\n            if (before && startTime > before.getTime()) break; // Check that we are within our range\n\n            if (isEventWithinRange(startTime, endTime)) {\n              if (exception) {\n                ret.events.push(exception);\n              } else if (!isOccurrenceExcluded) {\n                ret.occurrences.push(occurrence);\n              }\n            }\n          }\n        } while (next && (!this.maxIterations || i < this.maxIterations));\n\n        return;\n      } // Non-recurring event:\n\n\n      const _getTimes2 = getTimes(event),\n            startTime = _getTimes2.startTime,\n            endTime = _getTimes2.endTime;\n\n      if (isEventWithinRange(startTime, endTime)) ret.events.push(event);\n    });\n    return ret;\n  }\n\n  before(before) {\n    return this.between(undefined, before);\n  }\n\n  after(after) {\n    return this.between(after);\n  }\n\n  all() {\n    return this.between();\n  }\n\n}\n\nfunction registerTimezones() {\n  Object.keys(timezones).forEach(key => {\n    const icsData = timezones[key];\n    const icsTimezone = \"BEGIN:VTIMEZONE\\r\\nTZID:\".concat(key, \"\\r\\n\").concat(icsData, \"\\r\\nEND:VTIMEZONE\");\n    const parsed = ICAL.parse(\"BEGIN:VCALENDAR\\nPRODID:-//tzurl.org//NONSGML Olson 2012h//EN\\nVERSION:2.0\\n\".concat(icsTimezone, \"\\nEND:VCALENDAR\"));\n    const comp = new ICAL.Component(parsed);\n    const vtimezone = comp.getFirstSubcomponent('vtimezone');\n    ICAL.TimezoneService.register(key, new ICAL.Timezone(vtimezone));\n  });\n}\n\nregisterTimezones();\nmodule.exports = IcalExpander;","map":null,"metadata":{},"sourceType":"script"}