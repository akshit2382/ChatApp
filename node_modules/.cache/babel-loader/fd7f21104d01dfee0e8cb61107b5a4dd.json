{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport Textarea from 'react-textarea-autosize';\nimport getCaretCoordinates from 'textarea-caret';\nimport CustomEvent from 'custom-event';\nimport { isValidElementType } from 'react-is';\nimport Listeners, { KEY_CODES } from './listener';\nimport { List as DefaultSuggestionList } from './List';\nimport { DEFAULT_CARET_POSITION, defaultScrollToItem, errorMessage, triggerPropsCheck } from './utils';\nimport { CommandItem } from '../CommandItem/CommandItem';\nimport { UserItem } from '../UserItem/UserItem';\n\nvar ReactTextareaAutocomplete =\n/** @class */\nfunction (_super) {\n  __extends(ReactTextareaAutocomplete, _super);\n\n  function ReactTextareaAutocomplete(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.getSelectionPosition = function () {\n      if (!_this.textareaRef) return null;\n      return {\n        selectionEnd: _this.textareaRef.selectionEnd,\n        selectionStart: _this.textareaRef.selectionStart\n      };\n    };\n\n    _this.getSelectedText = function () {\n      if (!_this.textareaRef) return null;\n      var _a = _this.textareaRef,\n          selectionEnd = _a.selectionEnd,\n          selectionStart = _a.selectionStart;\n      if (selectionStart === selectionEnd) return null;\n      return _this.state.value.substr(selectionStart, selectionEnd - selectionStart);\n    };\n\n    _this.setCaretPosition = function (position) {\n      if (position === void 0) {\n        position = 0;\n      }\n\n      if (!_this.textareaRef) return;\n\n      _this.textareaRef.focus();\n\n      _this.textareaRef.setSelectionRange(position, position);\n    };\n\n    _this.getCaretPosition = function () {\n      if (!_this.textareaRef) return 0;\n      return _this.textareaRef.selectionEnd;\n    };\n\n    _this.addKeycodeSubmitListeners = function (keyCodes) {\n      keyCodes.forEach(function (arrayOfCodes) {\n        var submitValue = arrayOfCodes;\n\n        if (submitValue.length === 1) {\n          submitValue = submitValue[0];\n        } // does submitted keycodes include shift+Enter?\n\n\n        var shiftE = arrayOfCodes.every(function (code) {\n          return [16, 13].includes(code);\n        });\n        if (shiftE) _this.keycodeSubmitShiftE = true;\n        return Listeners.add(submitValue, function (e) {\n          return _this._onEnter(e);\n        });\n      });\n    };\n\n    _this._onEnter = function (event) {\n      if (!_this.textareaRef) return;\n      var trigger = _this.state.currentTrigger;\n\n      var hasFocus = _this.textareaRef.matches(':focus'); // Don't submit if the element doesn't have focus or the shift key is pressed, unless shift+Enter were provided as submit keys\n\n\n      if (!hasFocus || event.shiftKey === true && !_this.keycodeSubmitShiftE || event.shiftKey === true && !_this.props.keycodeSubmitKeys) {\n        return;\n      }\n\n      if (!trigger || !_this.state.data) {\n        // trigger a submit\n        _this._replaceWord();\n\n        if (_this.textareaRef) {\n          _this.textareaRef.selectionEnd = 0;\n        }\n\n        _this.props.handleSubmit(event);\n\n        _this._closeAutocomplete();\n      }\n    };\n\n    _this._onSpace = function () {\n      if (!_this.props.replaceWord || !_this.textareaRef) return; // don't change characters if the element doesn't have focus\n\n      var hasFocus = _this.textareaRef.matches(':focus');\n\n      if (!hasFocus) return;\n\n      _this._replaceWord();\n    };\n\n    _this._replaceWord = function () {\n      var value = _this.state.value;\n      var lastWordRegex = /([^\\s]+)(\\s*)$/;\n      var match = lastWordRegex.exec(value.slice(0, _this.getCaretPosition()));\n      var lastWord = match && match[1];\n      if (!lastWord) return;\n      var spaces = match[2];\n\n      var newWord = _this.props.replaceWord(lastWord);\n\n      if (newWord == null) return;\n      var textBeforeWord = value.slice(0, _this.getCaretPosition() - match[0].length);\n      var textAfterCaret = value.slice(_this.getCaretPosition(), -1);\n      var newText = textBeforeWord + newWord + spaces + textAfterCaret;\n\n      _this.setState({\n        value: newText\n      }, function () {\n        // fire onChange event after successful selection\n        var e = new CustomEvent('change', {\n          bubbles: true\n        });\n\n        _this.textareaRef.dispatchEvent(e);\n\n        if (_this.props.onChange) _this.props.onChange(e);\n      });\n    };\n\n    _this._onSelect = function (newToken) {\n      var _a = _this.props,\n          closeCommandsList = _a.closeCommandsList,\n          closeMentionsList = _a.closeMentionsList,\n          onChange = _a.onChange,\n          showCommandsList = _a.showCommandsList,\n          showMentionsList = _a.showMentionsList;\n      var _b = _this.state,\n          stateTrigger = _b.currentTrigger,\n          selectionEnd = _b.selectionEnd,\n          textareaValue = _b.value;\n      var currentTrigger = showCommandsList ? '/' : showMentionsList ? '@' : stateTrigger;\n      if (!currentTrigger) return;\n\n      var computeCaretPosition = function (position, token, startToken) {\n        switch (position) {\n          case 'start':\n            return startToken;\n\n          case 'next':\n          case 'end':\n            return startToken + token.length;\n\n          default:\n            if (!Number.isInteger(position)) {\n              throw new Error('RTA: caretPosition should be \"start\", \"next\", \"end\" or number.');\n            }\n\n            return position;\n        }\n      };\n\n      var textToModify = showCommandsList ? '/' : showMentionsList ? '@' : textareaValue.slice(0, selectionEnd);\n      var startOfTokenPosition = textToModify.lastIndexOf(currentTrigger); // we add space after emoji is selected if a caret position is next\n\n      var newTokenString = newToken.caretPosition === 'next' ? newToken.text + \" \" : newToken.text;\n      var newCaretPosition = computeCaretPosition(newToken.caretPosition, newTokenString, startOfTokenPosition);\n      var modifiedText = textToModify.substring(0, startOfTokenPosition) + newTokenString;\n      var valueToReplace = textareaValue.replace(textToModify, modifiedText); // set the new textarea value and after that set the caret back to its position\n\n      _this.setState({\n        dataLoading: false,\n        value: valueToReplace\n      }, function () {\n        // fire onChange event after successful selection\n        var e = new CustomEvent('change', {\n          bubbles: true\n        });\n\n        _this.textareaRef.dispatchEvent(e);\n\n        if (onChange) onChange(e);\n\n        _this.setCaretPosition(newCaretPosition);\n      });\n\n      _this._closeAutocomplete();\n\n      if (showCommandsList) closeCommandsList();\n      if (showMentionsList) closeMentionsList();\n    };\n\n    _this._getItemOnSelect = function (paramTrigger) {\n      var stateTrigger = _this.state.currentTrigger;\n\n      var triggerSettings = _this._getCurrentTriggerSettings(paramTrigger);\n\n      var currentTrigger = paramTrigger || stateTrigger;\n      if (!currentTrigger || !triggerSettings) return null;\n      var callback = triggerSettings.callback;\n      if (!callback) return null;\n      return function (item) {\n        if (typeof callback !== 'function') {\n          throw new Error('Output functor is not defined! You have to define \"output\" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');\n        }\n\n        if (callback) {\n          return callback(item, currentTrigger);\n        }\n\n        return null;\n      };\n    };\n\n    _this._getTextToReplace = function (paramTrigger) {\n      var _a = _this.state,\n          actualToken = _a.actualToken,\n          stateTrigger = _a.currentTrigger;\n\n      var triggerSettings = _this._getCurrentTriggerSettings(paramTrigger);\n\n      var currentTrigger = paramTrigger || stateTrigger;\n      if (!currentTrigger || !triggerSettings) return null;\n      var output = triggerSettings.output;\n      return function (item) {\n        if (typeof item === 'object' && (!output || typeof output !== 'function')) {\n          throw new Error('Output functor is not defined! If you are using items as object you have to define \"output\" function. https://github.com/webscopeio/react-textarea-autocomplete#trigger-type');\n        }\n\n        if (output) {\n          var textToReplace = output(item, currentTrigger);\n\n          if (!textToReplace || typeof textToReplace === 'number') {\n            throw new Error(\"Output functor should return string or object in shape {text: string, caretPosition: string | number}.\\nGot \\\"\" + String(textToReplace) + \"\\\". Check the implementation for trigger \\\"\" + currentTrigger + \"\\\" and its token \\\"\" + actualToken + \"\\\"\\n\\nSee https://github.com/webscopeio/react-textarea-autocomplete#trigger-type for more informations.\\n\");\n          }\n\n          if (typeof textToReplace === 'string') {\n            return {\n              caretPosition: DEFAULT_CARET_POSITION,\n              text: textToReplace\n            };\n          }\n\n          if (!textToReplace.text && currentTrigger !== ':') {\n            throw new Error(\"Output \\\"text\\\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \\\"\" + currentTrigger + \"\\\" and its token \\\"\" + actualToken + \"\\\"\\n\");\n          }\n\n          if (!textToReplace.caretPosition) {\n            throw new Error(\"Output \\\"caretPosition\\\" is not defined! Object should has shape {text: string, caretPosition: string | number}. Check the implementation for trigger \\\"\" + currentTrigger + \"\\\" and its token \\\"\" + actualToken + \"\\\"\\n\");\n          }\n\n          return textToReplace;\n        }\n\n        if (typeof item !== 'string') {\n          throw new Error('Output item should be string\\n');\n        }\n\n        return {\n          caretPosition: DEFAULT_CARET_POSITION,\n          text: \"\" + currentTrigger + item + currentTrigger\n        };\n      };\n    };\n\n    _this._getCurrentTriggerSettings = function (paramTrigger) {\n      var stateTrigger = _this.state.currentTrigger;\n      var currentTrigger = paramTrigger || stateTrigger;\n      if (!currentTrigger) return null;\n      return _this.props.trigger[currentTrigger];\n    };\n\n    _this._getValuesFromProvider = function () {\n      var _a = _this.state,\n          actualToken = _a.actualToken,\n          currentTrigger = _a.currentTrigger;\n\n      var triggerSettings = _this._getCurrentTriggerSettings();\n\n      if (!currentTrigger || !triggerSettings) return;\n      var component = triggerSettings.component,\n          dataProvider = triggerSettings.dataProvider;\n\n      if (typeof dataProvider !== 'function') {\n        throw new Error('Trigger provider has to be a function!');\n      }\n\n      _this.setState({\n        dataLoading: true\n      }); // Modified: send the full text to support / style commands\n\n\n      dataProvider(actualToken, _this.state.value, function (data, token) {\n        // Make sure that the result is still relevant for current query\n        if (token !== _this.state.actualToken) return;\n\n        if (!Array.isArray(data)) {\n          throw new Error('Trigger provider has to provide an array!');\n        }\n\n        if (!isValidElementType(component)) {\n          throw new Error('Component should be defined!');\n        } // throw away if we resolved old trigger\n\n\n        if (currentTrigger !== _this.state.currentTrigger) return; // if we haven't resolved any data let's close the autocomplete\n\n        if (!data.length) {\n          _this._closeAutocomplete();\n\n          return;\n        }\n\n        _this.setState({\n          component: component,\n          data: data,\n          dataLoading: false\n        });\n      });\n    };\n\n    _this._getSuggestions = function (paramTrigger) {\n      var _a = _this.state,\n          stateTrigger = _a.currentTrigger,\n          data = _a.data;\n      var currentTrigger = paramTrigger || stateTrigger;\n      if (!currentTrigger || !data || data && !data.length) return null;\n      return data;\n    };\n    /**\n     * Close autocomplete, also clean up trigger (to avoid slow promises)\n     */\n\n\n    _this._closeAutocomplete = function () {\n      _this.setState({\n        currentTrigger: null,\n        data: null,\n        dataLoading: false,\n        left: null,\n        top: null\n      });\n    };\n\n    _this._cleanUpProps = function () {\n      var props = __assign({}, _this.props);\n\n      var notSafe = ['additionalTextareaProps', 'className', 'closeCommandsList', 'closeMentionsList', 'closeOnClickOutside', 'containerClassName', 'containerStyle', 'disableMentions', 'dropdownClassName', 'dropdownStyle', 'grow', 'handleSubmit', 'innerRef', 'itemClassName', 'itemStyle', 'keycodeSubmitKeys', 'listClassName', 'listStyle', 'loaderClassName', 'loaderStyle', 'loadingComponent', 'minChar', 'movePopupAsYouType', 'onCaretPositionChange', 'onChange', 'ref', 'replaceWord', 'scrollToItem', 'showCommandsList', 'showMentionsList', 'SuggestionItem', 'SuggestionList', 'trigger', 'value']; // eslint-disable-next-line\n\n      for (var prop in props) {\n        if (notSafe.includes(prop)) delete props[prop];\n      }\n\n      return props;\n    };\n\n    _this._isCommand = function (text) {\n      if (text[0] !== '/') return false;\n      var tokens = text.split(' ');\n      if (tokens.length > 1) return false;\n      return true;\n    };\n\n    _this._changeHandler = function (e) {\n      var _a = _this.props,\n          minChar = _a.minChar,\n          movePopupAsYouType = _a.movePopupAsYouType,\n          onCaretPositionChange = _a.onCaretPositionChange,\n          onChange = _a.onChange,\n          trigger = _a.trigger;\n      var _b = _this.state,\n          left = _b.left,\n          top = _b.top;\n      var textarea = e.target;\n      var selectionEnd = textarea.selectionEnd,\n          selectionStart = textarea.selectionStart,\n          value = textarea.value;\n\n      if (onChange) {\n        e.persist();\n        onChange(e);\n      }\n\n      if (onCaretPositionChange) onCaretPositionChange(_this.getCaretPosition());\n\n      _this.setState({\n        value: value\n      });\n\n      var currentTrigger;\n      var lastToken;\n\n      if (_this._isCommand(value)) {\n        currentTrigger = '/';\n        lastToken = value;\n      } else {\n        var triggerTokens = Object.keys(trigger).join().replace('/', '');\n        var triggerNorWhitespace = \"[^\\\\s\" + triggerTokens + \"]*\";\n        var regex = new RegExp(\"(?!^|\\\\W)?[\" + triggerTokens + \"]\" + triggerNorWhitespace + \"\\\\s?\" + triggerNorWhitespace + \"$\", 'g');\n        var tokenMatch = value.slice(0, selectionEnd).match(regex);\n        lastToken = tokenMatch && tokenMatch[tokenMatch.length - 1].trim();\n        currentTrigger = lastToken && Object.keys(trigger).find(function (a) {\n          return a === lastToken[0];\n        }) || null;\n      }\n      /*\n       if we lost the trigger token or there is no following character we want to close\n       the autocomplete\n      */\n\n\n      if (!lastToken || lastToken.length <= minChar) {\n        _this._closeAutocomplete();\n\n        return;\n      }\n\n      var actualToken = lastToken.slice(1); // if trigger is not configured step out from the function, otherwise proceed\n\n      if (!currentTrigger) return;\n\n      if (movePopupAsYouType || top === null && left === null || // if we have single char - trigger it means we want to re-position the autocomplete\n      lastToken.length === 1) {\n        var _c = getCaretCoordinates(textarea, selectionEnd),\n            newLeft = _c.left,\n            newTop = _c.top;\n\n        _this.setState({\n          // make position relative to textarea\n          left: newLeft,\n          top: newTop - _this.textareaRef.scrollTop || 0\n        });\n      }\n\n      _this.setState({\n        actualToken: actualToken,\n        currentTrigger: currentTrigger,\n        selectionEnd: selectionEnd,\n        selectionStart: selectionStart\n      }, function () {\n        try {\n          _this._getValuesFromProvider();\n        } catch (err) {\n          errorMessage(err.message);\n        }\n      });\n    };\n\n    _this._selectHandler = function (e) {\n      var _a = _this.props,\n          onCaretPositionChange = _a.onCaretPositionChange,\n          onSelect = _a.onSelect;\n      if (onCaretPositionChange) onCaretPositionChange(_this.getCaretPosition());\n\n      if (onSelect) {\n        e.persist();\n        onSelect(e);\n      }\n    }; // The textarea itself is outside the auto-select dropdown.\n\n\n    _this._onClickAndBlurHandler = function (e) {\n      var _a = _this.props,\n          closeOnClickOutside = _a.closeOnClickOutside,\n          onBlur = _a.onBlur; // If this is a click: e.target is the textarea, and e.relatedTarget is the thing\n      // that was actually clicked. If we clicked inside the auto-select dropdown, then\n      // that's not a blur, from the auto-select point of view, so then do nothing.\n\n      var el = e.relatedTarget;\n\n      if (_this.dropdownRef && el instanceof Node && _this.dropdownRef.contains(el)) {\n        return;\n      }\n\n      if (closeOnClickOutside) _this._closeAutocomplete();\n\n      if (onBlur) {\n        e.persist();\n        onBlur(e);\n      }\n    };\n\n    _this._onScrollHandler = function () {\n      return _this._closeAutocomplete();\n    };\n\n    _this._dropdownScroll = function (item) {\n      var scrollToItem = _this.props.scrollToItem;\n      if (!scrollToItem) return;\n\n      if (scrollToItem === true) {\n        defaultScrollToItem(_this.dropdownRef, item);\n        return;\n      }\n\n      if (typeof scrollToItem !== 'function' || scrollToItem.length !== 2) {\n        throw new Error('`scrollToItem` has to be boolean (true for default implementation) or function with two parameters: container, item.');\n      }\n\n      scrollToItem(_this.dropdownRef, item);\n    };\n\n    _this.getTriggerProps = function () {\n      var _a = _this.props,\n          showCommandsList = _a.showCommandsList,\n          showMentionsList = _a.showMentionsList,\n          trigger = _a.trigger;\n      var _b = _this.state,\n          component = _b.component,\n          currentTrigger = _b.currentTrigger,\n          selectionEnd = _b.selectionEnd,\n          value = _b.value;\n\n      var selectedItem = _this._getItemOnSelect();\n\n      var suggestionData = _this._getSuggestions();\n\n      var textToReplace = _this._getTextToReplace();\n\n      var triggerProps = {\n        component: component,\n        currentTrigger: currentTrigger,\n        getSelectedItem: selectedItem,\n        getTextToReplace: textToReplace,\n        selectionEnd: selectionEnd,\n        value: value,\n        values: suggestionData\n      };\n\n      if (showCommandsList && trigger['/'] || showMentionsList && trigger['@']) {\n        var currentCommands_1;\n        var getCommands = trigger[showCommandsList ? '/' : '@'].dataProvider;\n        getCommands === null || getCommands === void 0 ? void 0 : getCommands('', showCommandsList ? '/' : '@', function (data) {\n          currentCommands_1 = data;\n        });\n        triggerProps.component = showCommandsList ? CommandItem : UserItem;\n        triggerProps.currentTrigger = showCommandsList ? '/' : '@';\n        triggerProps.getTextToReplace = _this._getTextToReplace(showCommandsList ? '/' : '@');\n        triggerProps.getSelectedItem = _this._getItemOnSelect(showCommandsList ? '/' : '@');\n        triggerProps.selectionEnd = 1;\n        triggerProps.value = showCommandsList ? '/' : '@';\n        triggerProps.values = currentCommands_1;\n      }\n\n      return triggerProps;\n    };\n\n    var _a = _this.props,\n        loadingComponent = _a.loadingComponent,\n        trigger = _a.trigger,\n        value = _a.value; // TODO: it would be better to have the parent control state...\n    // if (value) this.state.value = value;\n\n    if (!loadingComponent) {\n      throw new Error('RTA: loadingComponent is not defined');\n    }\n\n    if (!trigger) {\n      throw new Error('RTA: trigger is not defined');\n    }\n\n    _this.state = {\n      actualToken: '',\n      component: null,\n      currentTrigger: null,\n      data: null,\n      dataLoading: false,\n      keycodeSubmitShiftE: false,\n      left: null,\n      listenerIndex: {},\n      selectionEnd: 0,\n      selectionStart: 0,\n      top: null,\n      value: value || ''\n    };\n    return _this;\n  }\n\n  ReactTextareaAutocomplete.prototype.componentDidMount = function () {\n    var _this = this;\n\n    Listeners.add(KEY_CODES.ESC, function () {\n      return _this._closeAutocomplete();\n    });\n    Listeners.add(KEY_CODES.SPACE, function () {\n      return _this._onSpace();\n    });\n    var listenerIndex = {};\n    var newSubmitKeys = this.props.keycodeSubmitKeys;\n\n    if (newSubmitKeys) {\n      var keycodeIndex = this.addKeycodeSubmitListeners(newSubmitKeys);\n      listenerIndex[keycodeIndex] = keycodeIndex;\n    } else {\n      var enterIndex = Listeners.add(KEY_CODES.ENTER, function (e) {\n        return _this._onEnter(e);\n      });\n      listenerIndex[enterIndex] = enterIndex;\n    }\n\n    this.setState({\n      listenerIndex: listenerIndex\n    });\n    Listeners.startListen();\n  };\n\n  ReactTextareaAutocomplete.prototype.componentWillUnmount = function () {\n    Listeners.stopListen();\n    Listeners.remove(this.state.listenerIndex);\n  };\n  /**\n   * setup to emulate the UNSAFE_componentWillReceiveProps\n   */\n\n\n  ReactTextareaAutocomplete.getDerivedStateFromProps = function (props, state) {\n    if (props.value !== state.propsValue || !state.value) {\n      return {\n        propsValue: props.value,\n        value: props.value\n      };\n    } else {\n      return null;\n    }\n  };\n\n  ReactTextareaAutocomplete.prototype.renderSuggestionListContainer = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disableMentions = _a.disableMentions,\n        dropdownClassName = _a.dropdownClassName,\n        dropdownStyle = _a.dropdownStyle,\n        itemClassName = _a.itemClassName,\n        itemStyle = _a.itemStyle,\n        listClassName = _a.listClassName,\n        SuggestionItem = _a.SuggestionItem,\n        _b = _a.SuggestionList,\n        SuggestionList = _b === void 0 ? DefaultSuggestionList : _b;\n    var triggerProps = this.getTriggerProps();\n\n    if (triggerProps.values && triggerProps.currentTrigger && !(disableMentions && triggerProps.currentTrigger === '@')) {\n      return React.createElement(\"div\", {\n        className: \"rta__autocomplete \" + (dropdownClassName || ''),\n        ref: function (ref) {\n          _this.dropdownRef = ref;\n        },\n        style: dropdownStyle\n      }, React.createElement(SuggestionList, __assign({\n        className: listClassName,\n        dropdownScroll: this._dropdownScroll,\n        itemClassName: itemClassName,\n        itemStyle: itemStyle,\n        onSelect: this._onSelect,\n        SuggestionItem: SuggestionItem\n      }, triggerProps)));\n    }\n\n    return null;\n  };\n\n  ReactTextareaAutocomplete.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        className = _a.className,\n        containerClassName = _a.containerClassName,\n        containerStyle = _a.containerStyle,\n        style = _a.style;\n    var maxRows = this.props.maxRows;\n    var _b = this.state,\n        dataLoading = _b.dataLoading,\n        value = _b.value;\n    if (!this.props.grow) maxRows = 1;\n    return React.createElement(\"div\", {\n      className: \"rta \" + (dataLoading === true ? 'rta--loading' : '') + \" \" + (containerClassName || ''),\n      style: containerStyle\n    }, this.renderSuggestionListContainer(), React.createElement(Textarea, __assign({}, this._cleanUpProps(), {\n      className: \"rta__textarea \" + (className || ''),\n      maxRows: maxRows,\n      onBlur: this._onClickAndBlurHandler,\n      onChange: this._changeHandler,\n      onClick: this._onClickAndBlurHandler,\n      onFocus: this.props.onFocus,\n      onScroll: this._onScrollHandler,\n      onSelect: this._selectHandler,\n      ref: function (ref) {\n        if (_this.props.innerRef) _this.props.innerRef(ref);\n        _this.textareaRef = ref;\n      },\n      style: style,\n      value: value\n    }, this.props.additionalTextareaProps)));\n  };\n\n  ReactTextareaAutocomplete.defaultProps = {\n    closeOnClickOutside: true,\n    maxRows: 10,\n    minChar: 1,\n    movePopupAsYouType: false,\n    scrollToItem: true,\n    value: ''\n  };\n  return ReactTextareaAutocomplete;\n}(React.Component);\n\nexport { ReactTextareaAutocomplete };\nReactTextareaAutocomplete.propTypes = {\n  className: PropTypes.string,\n  closeOnClickOutside: PropTypes.bool,\n  containerClassName: PropTypes.string,\n  containerStyle: PropTypes.object,\n  disableMentions: PropTypes.bool,\n  dropdownClassName: PropTypes.string,\n  dropdownStyle: PropTypes.object,\n  itemClassName: PropTypes.string,\n  itemStyle: PropTypes.object,\n  keycodeSubmitKeys: PropTypes.array,\n  listClassName: PropTypes.string,\n  listStyle: PropTypes.object,\n  loaderClassName: PropTypes.string,\n  loaderStyle: PropTypes.object,\n  loadingComponent: PropTypes.elementType,\n  minChar: PropTypes.number,\n  onBlur: PropTypes.func,\n  onCaretPositionChange: PropTypes.func,\n  onChange: PropTypes.func,\n  onSelect: PropTypes.func,\n  style: PropTypes.object,\n  SuggestionList: PropTypes.elementType,\n  trigger: triggerPropsCheck,\n  value: PropTypes.string\n};","map":null,"metadata":{},"sourceType":"module"}