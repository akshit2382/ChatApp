{"ast":null,"code":"'use strict';\n\nconst emptyString = '';\n/**\n@private\n*/\n\nclass StringScanner {\n  /**\n  @param {string} string\n  */\n  constructor(string) {\n    /** @type {string[]} */\n    this.chars = [...string];\n    /** @type {number} */\n\n    this.charCount = this.chars.length;\n    /** @type {number} */\n\n    this.charIndex = 0;\n    /** @type {number[]} */\n\n    this.charsToBytes = new Array(this.charCount);\n    /** @type {boolean} */\n\n    this.multiByteMode = false;\n    /** @type {string} */\n\n    this.string = string;\n    let chars = this.chars,\n        charCount = this.charCount,\n        charsToBytes = this.charsToBytes;\n\n    if (charCount === string.length) {\n      // There are no multibyte characters in the input string, so char indexes\n      // and byte indexes are the same.\n      for (let i = 0; i < charCount; ++i) {\n        charsToBytes[i] = i;\n      }\n    } else {\n      // Create a mapping of character indexes to byte indexes. When the string\n      // contains multibyte characters, a byte index may not necessarily align\n      // with a character index.\n      for (let byteIndex = 0, charIndex = 0; charIndex < charCount; ++charIndex) {\n        charsToBytes[charIndex] = byteIndex;\n        byteIndex += chars[charIndex].length;\n      }\n\n      this.multiByteMode = true;\n    }\n  }\n  /**\n  Whether the current character index is at the end of the input string.\n   @type {boolean}\n  */\n\n\n  get isEnd() {\n    return this.charIndex >= this.charCount;\n  } // -- Protected Methods ------------------------------------------------------\n\n  /**\n  Returns the number of characters in the given _string_, which may differ from\n  the byte length if the string contains multibyte characters.\n   @param {string} string\n  @returns {number}\n  */\n\n\n  _charLength(string) {\n    let length = string.length;\n\n    if (length < 2 || !this.multiByteMode) {\n      return length;\n    } // We could get the char length with `[ ...string ].length`, but that's\n    // actually slower than this approach, which replaces surrogate pairs with\n    // single-byte characters.\n\n\n    return string.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, '_').length;\n  } // -- Public Methods ---------------------------------------------------------\n\n  /**\n  Advances the scanner by the given number of characters, stopping if the end of\n  the string is reached.\n   @param {number} [count]\n  */\n\n\n  advance(count = 1) {\n    this.charIndex = Math.min(this.charCount, this.charIndex + count);\n  }\n  /**\n  Consumes and returns the given number of characters if possible, advancing the\n  scanner and stopping if the end of the string is reached.\n   If no characters could be consumed, an empty string will be returned.\n   @param {number} [count]\n  @returns {string}\n  */\n\n\n  consume(count = 1) {\n    let chars = this.peek(count);\n    this.advance(count);\n    return chars;\n  }\n  /**\n  Consumes a match for the given sticky regex, advances the scanner, updates the\n  `lastIndex` property of the regex, and returns the matching string.\n   The regex must have a sticky flag (\"y\") so that its `lastIndex` prop can be\n  used to anchor the match at the current scanner position.\n   Returns the consumed string, or an empty string if nothing was consumed.\n   @param {RegExp} regex\n  @returns {string}\n  */\n\n\n  consumeMatch(regex) {\n    if (!regex.sticky) {\n      throw new Error('`regex` must have a sticky flag (\"y\")');\n    }\n\n    regex.lastIndex = this.charsToBytes[this.charIndex];\n    let result = regex.exec(this.string);\n\n    if (result === null) {\n      return emptyString;\n    }\n\n    let match = result[0];\n    this.advance(this._charLength(match));\n    return match;\n  }\n  /**\n  Consumes and returns all characters for which the given function returns a\n  truthy value, stopping on the first falsy return value or if the end of the\n  input is reached.\n   @param {(char: string) => boolean} fn\n  @returns {string}\n  */\n\n\n  consumeMatchFn(fn) {\n    let startIndex = this.charIndex;\n\n    while (!this.isEnd && fn(this.peek())) {\n      this.advance();\n    }\n\n    return this.charIndex > startIndex ? this.string.slice(this.charsToBytes[startIndex], this.charsToBytes[this.charIndex]) : emptyString;\n  }\n  /**\n  Consumes the given string if it exists at the current character index, and\n  advances the scanner.\n   If the given string doesn't exist at the current character index, an empty\n  string will be returned and the scanner will not be advanced.\n   @param {string} stringToConsume\n  @returns {string}\n  */\n\n\n  consumeString(stringToConsume) {\n    if (this.consumeStringFast(stringToConsume)) {\n      return stringToConsume;\n    }\n\n    if (!this.multiByteMode) {\n      return emptyString;\n    }\n\n    let length = stringToConsume.length;\n\n    let charLengthToMatch = this._charLength(stringToConsume);\n\n    if (charLengthToMatch !== length && stringToConsume === this.peek(charLengthToMatch)) {\n      this.advance(charLengthToMatch);\n      return stringToConsume;\n    }\n\n    return emptyString;\n  }\n  /**\n   * Does the same thing as `consumeString()`, but doesn't support consuming\n   * multibyte characters. This can be much faster if you only need to match\n   * single byte characters.\n   *\n   * @param {string} stringToConsume\n   * @returns {string}\n   */\n\n\n  consumeStringFast(stringToConsume) {\n    if (this.peek() === stringToConsume[0]) {\n      let length = stringToConsume.length;\n\n      if (length === 1) {\n        this.advance();\n        return stringToConsume;\n      }\n\n      if (this.peek(length) === stringToConsume) {\n        this.advance(length);\n        return stringToConsume;\n      }\n    }\n\n    return emptyString;\n  }\n  /**\n  Consumes characters until the given global regex is matched, advancing the\n  scanner up to (but not beyond) the beginning of the match and updating the\n  `lastIndex` property of the regex.\n   The regex must have a global flag (\"g\") so that its `lastIndex` prop can be\n  used to begin the search at the current scanner position.\n   Returns the consumed string, or an empty string if nothing was consumed.\n   @param {RegExp} regex\n  @returns {string}\n  */\n\n\n  consumeUntilMatch(regex) {\n    if (!regex.global) {\n      throw new Error('`regex` must have a global flag (\"g\")');\n    }\n\n    let byteIndex = this.charsToBytes[this.charIndex];\n    regex.lastIndex = byteIndex;\n    let match = regex.exec(this.string);\n\n    if (match === null || match.index === byteIndex) {\n      return emptyString;\n    }\n\n    let result = this.string.slice(byteIndex, match.index);\n    this.advance(this._charLength(result));\n    return result;\n  }\n  /**\n  Consumes characters until the given string is found, advancing the scanner up\n  to (but not beyond) that point.\n   Returns the consumed string, or an empty string if nothing was consumed.\n   @param {string} searchString\n  @returns {string}\n  */\n\n\n  consumeUntilString(searchString) {\n    let charIndex = this.charIndex,\n        charsToBytes = this.charsToBytes,\n        string = this.string;\n    let byteIndex = charsToBytes[charIndex];\n    let matchByteIndex = string.indexOf(searchString, byteIndex);\n\n    if (matchByteIndex <= 0) {\n      return emptyString;\n    }\n\n    let result = string.slice(byteIndex, matchByteIndex);\n    this.advance(this._charLength(result));\n    return result;\n  }\n  /**\n  Returns the given number of characters starting at the current character\n  index, without advancing the scanner and without exceeding the end of the\n  input string.\n   @param {number} [count]\n  @returns {string}\n  */\n\n\n  peek(count = 1) {\n    // Inlining this comparison instead of checking `this.isEnd` improves perf\n    // slightly since `peek()` is called so frequently.\n    if (this.charIndex >= this.charCount) {\n      return emptyString;\n    }\n\n    if (count === 1) {\n      return this.chars[this.charIndex];\n    }\n\n    let charsToBytes = this.charsToBytes,\n        charIndex = this.charIndex;\n    return this.string.slice(charsToBytes[charIndex], charsToBytes[charIndex + count]);\n  }\n  /**\n  Resets the scanner position to the given character _index_, or to the start of\n  the input string if no index is given.\n   If _index_ is negative, the scanner position will be moved backward by that\n  many characters, stopping if the beginning of the string is reached.\n   @param {number} [index]\n  */\n\n\n  reset(index = 0) {\n    this.charIndex = index >= 0 ? Math.min(this.charCount, index) : Math.max(0, this.charIndex + index);\n  }\n\n}\n\nmodule.exports = StringScanner;","map":null,"metadata":{},"sourceType":"script"}