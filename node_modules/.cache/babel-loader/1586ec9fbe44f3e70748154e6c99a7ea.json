{"ast":null,"code":"import { useCallback, useEffect, useRef } from 'react';\nimport { logChatPromiseExecution } from 'stream-chat';\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nexport var useMessageInputText = function (props, state, dispatch) {\n  var channel = useChannelStateContext('useMessageInputText').channel;\n  var additionalTextareaProps = props.additionalTextareaProps,\n      focus = props.focus,\n      parent = props.parent,\n      _a = props.publishTypingEvent,\n      publishTypingEvent = _a === void 0 ? true : _a;\n  var text = state.text;\n  var textareaRef = useRef(); // Focus\n\n  useEffect(function () {\n    if (focus && textareaRef.current) {\n      textareaRef.current.focus();\n    }\n  }, [focus]); // Text + cursor position\n\n  var newCursorPosition = useRef();\n  var insertText = useCallback(function (textToInsert) {\n    var maxLength = (additionalTextareaProps || {}).maxLength;\n\n    if (!textareaRef.current) {\n      dispatch({\n        getNewText: function (text) {\n          var updatedText = text + textToInsert;\n\n          if (maxLength && updatedText.length > maxLength) {\n            return updatedText.slice(0, maxLength);\n          }\n\n          return updatedText;\n        },\n        type: 'setText'\n      });\n      return;\n    }\n\n    var _a = textareaRef.current,\n        selectionEnd = _a.selectionEnd,\n        selectionStart = _a.selectionStart;\n    newCursorPosition.current = selectionStart + textToInsert.length;\n    dispatch({\n      getNewText: function (prevText) {\n        var updatedText = prevText.slice(0, selectionStart) + textToInsert + prevText.slice(selectionEnd);\n\n        if (maxLength && updatedText.length > maxLength) {\n          return updatedText.slice(0, maxLength);\n        }\n\n        return updatedText;\n      },\n      type: 'setText'\n    });\n  }, [additionalTextareaProps, newCursorPosition, textareaRef]);\n  useEffect(function () {\n    var textareaElement = textareaRef.current;\n\n    if (textareaElement && newCursorPosition.current !== undefined) {\n      textareaElement.selectionStart = newCursorPosition.current;\n      textareaElement.selectionEnd = newCursorPosition.current;\n      newCursorPosition.current = undefined;\n    }\n  }, [text, newCursorPosition]);\n  var handleChange = useCallback(function (event) {\n    event.preventDefault();\n\n    if (!event || !event.target) {\n      return;\n    }\n\n    var newText = event.target.value;\n    dispatch({\n      getNewText: function () {\n        return newText;\n      },\n      type: 'setText'\n    });\n\n    if (publishTypingEvent && newText && channel) {\n      logChatPromiseExecution(channel.keystroke(parent === null || parent === void 0 ? void 0 : parent.id), 'start typing event');\n    }\n  }, [channel, parent, publishTypingEvent]);\n  return {\n    handleChange: handleChange,\n    insertText: insertText,\n    textareaRef: textareaRef\n  };\n};","map":null,"metadata":{},"sourceType":"module"}