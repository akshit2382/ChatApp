{"ast":null,"code":"import { useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport { useMessageListScrollManager } from './useMessageListScrollManager';\nexport var useScrollLocationLogic = function (params) {\n  var _a = params.messages,\n      messages = _a === void 0 ? [] : _a,\n      _b = params.scrolledUpThreshold,\n      scrolledUpThreshold = _b === void 0 ? 200 : _b;\n\n  var _c = useState(false),\n      hasNewMessages = _c[0],\n      setHasNewMessages = _c[1];\n\n  var _d = useState(),\n      wrapperRect = _d[0],\n      setWrapperRect = _d[1];\n\n  var closeToBottom = useRef(false);\n  var closeToTop = useRef(false);\n  var listRef = useRef(null);\n  var scrollToBottom = useCallback(function () {\n    var _a, _b;\n\n    if (!((_a = listRef.current) === null || _a === void 0 ? void 0 : _a.scrollTo)) return;\n    (_b = listRef.current) === null || _b === void 0 ? void 0 : _b.scrollTo({\n      top: listRef.current.scrollHeight\n    });\n    setHasNewMessages(false); // this is hacky and unreliable, but that was the current implementation so not breaking it\n\n    setTimeout(function () {\n      var _a;\n\n      (_a = listRef.current) === null || _a === void 0 ? void 0 : _a.scrollTo({\n        top: listRef.current.scrollHeight\n      });\n    }, 200);\n  }, [listRef]);\n  useLayoutEffect(function () {\n    if (listRef === null || listRef === void 0 ? void 0 : listRef.current) {\n      setWrapperRect(listRef.current.getBoundingClientRect());\n      scrollToBottom();\n    }\n  }, [listRef]);\n  var updateScrollTop = useMessageListScrollManager({\n    messages: messages,\n    onScrollBy: function (scrollBy) {\n      var _a;\n\n      return (_a = listRef.current) === null || _a === void 0 ? void 0 : _a.scrollBy({\n        top: scrollBy\n      });\n    },\n    scrollContainerMeasures: function () {\n      var _a, _b;\n\n      return {\n        offsetHeight: ((_a = listRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0,\n        scrollHeight: ((_b = listRef.current) === null || _b === void 0 ? void 0 : _b.scrollHeight) || 0\n      };\n    },\n    scrolledUpThreshold: scrolledUpThreshold,\n    scrollToBottom: scrollToBottom,\n    showNewMessages: function () {\n      return setHasNewMessages(true);\n    }\n  });\n  var onScroll = useCallback(function (event) {\n    var element = event.target;\n    var scrollTop = element.scrollTop;\n    updateScrollTop(scrollTop);\n    var offsetHeight = element.offsetHeight;\n    var scrollHeight = element.scrollHeight;\n    closeToBottom.current = scrollHeight - (scrollTop + offsetHeight) < scrolledUpThreshold;\n    closeToTop.current = scrollTop < scrolledUpThreshold;\n\n    if (closeToBottom.current) {\n      setHasNewMessages(false);\n    }\n  }, [updateScrollTop, closeToTop, closeToBottom, scrolledUpThreshold]);\n  var onMessageLoadCaptured = useCallback(function () {\n    /**\n     * A load event (emitted by e.g. an <img>) was captured on a message.\n     * In some cases, the loaded asset is larger than the placeholder, which means we have to scroll down.\n     */\n    if (closeToBottom.current && !closeToTop.current) {\n      scrollToBottom();\n    }\n  }, [closeToTop, closeToBottom, scrollToBottom]);\n  return {\n    hasNewMessages: hasNewMessages,\n    listRef: listRef,\n    onMessageLoadCaptured: onMessageLoadCaptured,\n    onScroll: onScroll,\n    scrollToBottom: scrollToBottom,\n    wrapperRect: wrapperRect\n  };\n};","map":null,"metadata":{},"sourceType":"module"}